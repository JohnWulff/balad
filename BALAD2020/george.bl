#!/usr/bin/balad
########################################################################
#
#	Copyright (C) 2020  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the next line.
#
#	SPDX-License-Identifier: GPL-3.0+ OR Artistic-2.0
#
#  Reverse Polish Notation Calculator 'GEORGE'
#
#	see help text at the end of the file for a full description 
#
#  Historical Note: I wrote my first computer program in 1957 for a
#  Reverse Polish Notation Calculater called 'GEORGE', which ran as an
#  interpreter on the 'UTECOM' computer at the University of NSW. UTECOM
#  was the third digital electronic computer installed in Australia.  It
#  nearly filled a large room in the first building on the campus in
#  Kensington.
#
#  GEORGE had been written by one of my lecturers, who was teaching us
#  Boolean Logic as part of a philosophy course. In 1956 UTECOM had
#  384 x 32 bit words of memory implemented as 12 mercury delay lines.
#  This is very similar in memory size and precision to the BALAD
#  computer, which was first implemented by me in 1970 as a teaching aid.
#
#  I have named this program 'george.bl' in honour of my former lecturer.
#
#  $Id: george.bl 1.3 $
#
########################################################################

######  Variables and constants  #######################################

	LOC 2

dest:	0l		; double precision result
swpPfr:
src:	0l		; double precision src
swpPto:
quotit:			; double precision quotient for div
mulcnd:	0l		; double precision multiplicand for simple mult
swpP:
opOfs:
mulplr:	0		; single precision multiplier   for simple mult
savACC:	0		; used in main swpNow and mult
sign:	0		; used locally in add sub (mul div via setSgn tstSgn)
expPTR:	0		; byte pointer into epression string (global)
stackP:	0		; stack pointer                      (global)
digits:	0		; count digits in a number           (global)
showFl:	0		;                                    (global)
hexFl:	0		;                                    (global)
inBase:	0		;                                    (global)
asBase:	0		;                                    (global)
expADR:	ADR expr	; word address of expression string
stackA:	ADR stack	; top of stack (growing downwards)
funPAd:	ADR @addADR	; indirect address of function pointer list
addADR:	ADR add		; function pointer list array
	ADR sub
	ADR mul
	ADR div
space:	" "		; white space
tab:	"\t"
nl:	"\n"
addOp:	"+"		; + token
subOp:	"-"		; - token
mulOp:	"*"		; * token
divOp:	"/"		; / token
ASC_0:	"0"
ASC_9_:	":"		; "9"+1
ASC_a:	"a"
ASC_f_:	"g"		; "f"+1
ASC_C:	"C"
ASC_D:	"D"
ASC_E:	"E"
ASC_R:	"R"
ASC_S:	"S"
ASC_n:	"n"
ASC_d:	"d"
ASC_o:	"o"
ASC_x:	"x"
ASC_b:	"b"
ASC_q:	"q"
D10:	10
D16:	16
D2:	2
D4:	4
D8:	8
D87:	87		; "a"-10 convert a -f to 10 -15
C177:	0177		; character mask
C40000:	040000		; sign bit
prompt:	"RPN"
fmtDP:	" %#ld"		; should be near the front so no backward reference
errMsg:	"? err\n";

######  Start of main program  #########################################

	LOC 100

main:	LDA stackA	; top of stack - clear the stack
	STA stackP	; stack grows downwards towards 'expr'

########################################################################
#  Get a new RPN expression string
########################################################################

loop:	KCS expr	; grow expression upwards towards stack
	LDA expADR	; expr[] address
	STA expPTR	; word pointer first
	JMS iniDig	; clear digits, hexFl -1, decimal base, C
	JMP gettok+1	; skip first ROR - start with even byte of expr[0]

########################################################################
#  Get another byte token from the expression string
########################################################################

gettok:	ROR expPTR	; change to word pointer and carry for odd bytes
	LDA @expPTR	; two bytes from the expression
	JZC .+2		; skip SWP for even bytes
	SWP ACC		; swap bytes for odd bytes
	ROL expPTR	; change to byte pointer
	INC expPTR	; increment expression byte pointer
	AND C177	; mask to 7 bit character from expression

########################################################################
#  0 - 9 a - f  analyze number input
########################################################################

	CMP ASC_0	; "0"
	JLT notDig
	CMP asBase	; "9"+1, "8", "2", "f"+1
	JGE notDig

	TST hexFl	; 1 before 0x, 0 after 0x, else -1 -2 etc
	JNR digFd	; 0 - 9, 0 - 7 or 0-1 found

	CMP ASC_a	; hex -must test "a" first
	JLT notA_F	; not a - f
	SUB D87		; "a"-10 convert a -f to 10 -15
	JMP convrt

notA_F:	CMP ASC_9_	; "9"+1
	JGE notDig	; fall through for hex 0 - 9

digFd:	SUB ASC_0	; convert ascii to binary 0 - 9
convrt:	STA savACC	; save accumulator

	TST digits	; is this the first digit ?
	JNR num1	; no
	CLR dest	; yes - first digit
	CLR dest+1	; clear DP result for new number
	TST ACC		; is first digit '0' ?
	JNR num1	; no
	INC ACC		; yes
	INC digits	; 1 - first '0' is a number, even by itself
	STA hexFl	; 1 look for x or b after first digit 0
	LDA D8
	STA inBase	; change input base to octal for now
	ADD ASC_0	; "8" is ascii base - end of number range
	JMP stAsB	; no need to convert first digit '0'

########################################################################
#  0 - 9 a - f  Build an unsigned integer in 'dest'
#	TODO - check for number overflow
#  **** There is not enough room in the BALAD memory to do this check
########################################################################

num1:	INC digits	; number is growing
	LDA inBase	; 10, 8, 16 or 2
	STA mulplr	; multiplier
	LDA dest	; lo part of previous number
	STA mulcnd	; multiplicand
	CLR mulcnd+1
	LDA savACC	; restore accumulator - new binary digit
	JMS mult
	STA dest	; store lo part of number
	LDA inBase	; 10, 8, 16 or 2
	STA mulplr	; multiplier
	LDA dest+1
	STA mulcnd	; multiplicand
	CLR mulcnd+1
	LDA ACC+1	; hi part of lo order multiplication
	JMS mult
	STA dest+1	; store hi part of number - TODO check for overflow
	JMP gettok	; get next digit or next operator

########################################################################
#  Not a digit - check for 0x and 0b
########################################################################

notDig:	STA savACC	; save accumulator
	DEC hexFl	; was there a first digit 0 ?
	JNR notNum	; no (hexFl changes after first digit)
	CMP ASC_x	; yes - hexFlag is now 0 - is this "x" ?
	JNE tst_b	; no
	LDA D16		; yes
	STA inBase	; change input base to hexadecimal
	LDA ASC_f_
	JMP stAsB	; 0x is a hex number - leave hexFl 0

tst_b:	CMP ASC_b	; yes - is this "b" ?
	JNE notNum	; no
	DEC hexFl	; hexFl now -1 means not hex; C is 1
	CLR C		; C must be 0 for next digit
	LDA D2		; yes
	STA inBase	; change input base to binary
	ADD ASC_0	; "2"
stAsB:	STA asBase
	JMP gettok	; 0b is a binary number

########################################################################
#  Test RPN token in ACC
#  Operations which do not require a push of a possible new number
########################################################################

notNum:	CMP ASC_q	; "q"
	JZR halt	; quit the program

	CMP ASC_C	; "C"
	JZR main	; Clear the stack

	CMP ASC_E	; "E"
	JNR tstNum

	JMS push	; Enter or duplicate number on stack
	JMS iniDig	; clear digits, hexFl -1, decimal base, C
	CLR showFl	; show stack after pushing a new number
	JMP gettok

########################################################################
#  Push a newly built number unless already pushed
########################################################################

tstNum:	TST digits	; has a number been built ?
	JZR noNum	; no - no new number

	JMS push	; yes - push the new number
	JMS iniDig	; clear digits, hexFl -1, decimal base, C
	CLR showFl	; show stack after pushing a new number

noNum:	LDA savACC	; restore accumulator
	JZR expEnd	; end of expression - show result
			; unless just shown with 'd' 'o' 'x' or 'b'
	CMP space
	JZR gettok	; ignore white space
	CMP tab
	JZR gettok

########################################################################
#  Analyze further RPN tokens
########################################################################

	CLR showFl	; all other tokens force showing the stack again
	CLR opOfs	; 0 add (share with mulplr)
	CMP addOp	; "+"
	JZR execOp
	INC opOfs	; 1 sub
	CMP subOp	; "-"
	JZR execOp
	INC opOfs	; 2 mul
	CMP mulOp	; "*"
	JZR execOp
	INC opOfs	; 3 div
	CMP divOp	; "/"
	JNE test_n

########################################################################
#  Lambda operation using a computed subroutine call from src and dest.
#	dest = dest op src	# for op = + - * and /
########################################################################

execOp:	JMS pop		; popped value to src and src+1
	LDA dest
	STA src
	LDA dest+1
	STA src+1
	JMS pop		; popped value is in dest and dest+1
	LDA funPAd	; address of function pointer list
	ADD opOfs	; select offset for add sub mul or div
	JMS @ACC	; execute the selected operation add sub mul div
	JMP pushDs	; push result from dest and dest+1

########################################################################
#  miscellaneous operators
########################################################################

test_n:	CMP ASC_n	; "n"
	JNE test_D
	JMS pop		; n negate last value on the stack
	JMS negate	; DP negate destination
pushDs:	JMS push	; push result from dest and dest+1
	JMP gettok	; next token

test_D:	CMP ASC_D	; "D"
	JNE test_S
	JMS pop		; Drop last value on the stack
	JMP gettok

test_S:	CMP ASC_S	; "S"
	JNE test_R
	LDA stackP	; Swap last two numbers on the stack
	ADD D4
	JMP swpNow

test_R:	CMP ASC_R	; "R"
	JNE test_d
	LDA stackA	; Roll last number on the stack with top of stack

########################################################################
#  Swap or Roll numbers on the stack
#	swpP = StackP + 4 for Swap last two numbers on the stack
#	swpP = stackA     for Roll last number to the top of the stack
#	Error if only one value on the stack - stack unchanged
########################################################################

swpNow:	STA swpP	; share with mulplr and opOfs
	LDA stackP
	STA savACC	; save stack pointer
	JMS pop		; last number on the stack (also checks empty stack)
	LDA stackP	; last number now in 'dest'
	CMP stackA
	JLT swp1
	PRF errMsg	; "? err\n"
	JMP swp2	; restore stack

swp1:	STA swpPfr	; share with src
	SUB D2
	STA swpPto	; share with mulcnd
	LDA swpP
	STA stackP

swpLp:	LDA @swpPfr	; move numbers down on the stack
	INC swpPfr
	STA @swpPto
	INC swpPto
	LDA swpPfr
	CMP stackP	; until top for swap or roll is reached
	JLT swpLp

swp2:	JMS push	; push last number on stack to hole further up the stack
	LDA savACC
	STA stackP	; restore stack pointer
	JMP gettok

########################################################################
#  select the base for the showSt() function and show the stack
########################################################################

test_d:	CMP ASC_d	; "d"	decimal
	JEQ show

	CMP ASC_o	; "o"	octal
	JEQ show

	CMP ASC_x	; "x"	hexadecimal
	JEQ show

	CMP ASC_b	; "b"	binary
	JEQ show

########################################################################
#  Input error - RPN token not recognized
########################################################################

	PRF inpEms	; "? %c\n"
	ADR ACC		; token is character in the accumulator
	JMP gettok

########################################################################
#  d o x b Show intermediate results remaining in the stack
########################################################################

show:	JMS showSt	; " %#ld" " %#lo" " %#lx" " %#lb"
	INC showFl	; no need to show stack again if terminated now
	JMP gettok

########################################################################
#  End of RPN expression - show current values on the stack in decimal
########################################################################

expEnd:	TST showFl	; was output shown already
	JNR loop	; yes - don't show again
	LDA ASC_d	; no  - restore decimal output
	JMS showSt	; " %#ld"
	JMP loop	; get new RPN expression

halt:	HLT

######  End of main program  ###########################################

######  Strings  #######################################################

inpEms:	"? %c\n"

######  Subroutines  ###################################################

########################################################################
#  clear digits, hexFl -1, decimal base, C
########################################################################

iniDig:	0
	CLR digits	; 0  start a new number
	CLR hexFl
	DEC hexFl	; -1; not hex; C is 1
	LDA D10		; assume initial decimal input
	STA inBase	; change input base to decimal
	LDA ASC_9_
	STA asBase
	CLR C		; C must be 0 for first byte of gettoken
	JMP @iniDig

########################################################################
#  push a double precision number on the stack downwards
#	double precision value to be pushed in dest and dest+1
#	TODO - check stackP meeting end of expression
#  **** There is not enough room in the BALAD memory to do this check
########################################################################

push:	0
	LDA dest+1
	DEC stackP
	STA @stackP
	LDA dest
	DEC stackP	; points to current DP number pushed onto stack
	STA @stackP
	JMP @push

########################################################################
#  pop a double precision number from the stack upwards
#	return Ok    double precision number in dest and dest+1
#	bail out to loop: on Error stack is empty
########################################################################

pop:	0
	LDA stackP
	CMP stackA
	JLT popOk
	PRF errMsg	; "? err\n"
	JMP loop	; stack is empty error

popOk:	LDA @stackP
	INC stackP
	STA dest
	LDA @ stackP
	INC stackP	; points to next DP number to be popped
	STA dest+1
	JMP @pop

########################################################################
#  Show all results remaining on the stack
#  This is done at the end of an input expression and for the d operation
#  as well as the o, x and b output operations with base 8, 16 and 2
#	arg1	ACC	; character d o x b replacing d in " %#ld"
########################################################################

showSt:	0
	STA fmtDP+2	; " %#ld" " %#lo" " %#lx" " %#lb"
	LDA stackA	; stack address to temporary stack pointer in ACC
	CLR C
showNx:	CMP stackP
	JLE showEn	; current end of stack
	SUB D2		; decrement by 2
	PRF fmtDP	; " %#ld" " %#lo" " %#lx" " %#lb"
	ADR @ACC	; indirect pointer to value on the stack
	JMP showNx
showEn:	PCH nl		; "\n"
	JMP @showSt

########################################################################
#
#  Simple unsigned multiply using rotate right of the multiplyer and
#  repeated addition of the left shifted multiplicand for every bit of
#  the multiplyer
#
#	JMS mult
#	arg1	ACC	; value added to the result     - lost
#	arg2	mulcnd	; double precision multiplicand	- lost
#	arg3	mulplr	; single precision multiplier	- lost
#	return	ACC,ACC+1 	; double precision result
#	    savACC	; temp save ACC is free in main before JMS mult
#
########################################################################

mult:	0		; ACC added to lo part of result
	CLR ACC+1	; hi part of result initially zero
mulLp:	TST mulplr	; is multiplyer all 0's ?
	JZR @mult	; yes - return DP result in ACC,ACC+1
	CLR C		; no
	ROR mulplr	; next bit of multiplyer
	JZC mulSkp	;  0  skip addition of multiplicand
	CLR C		;  1  DP add to result
	ADD mulcnd	; add shifted lo multiplicand to lo result
	STA savACC	; save ACC
	LDA ACC+1	; hi result
	ADD mulcnd+1	; add shifted hi multiplicand to hi result
	STA ACC+1
	LDA savACC	; restore ACC
mulSkp:	CLR C
	ROL mulcnd	; double precision shift left of multiplicand
	ROL mulcnd+1
	JMP mulLp

########################################################################
#  double precision negate
#	dest = -dest
#	return double precision number in dest and dest+1
#	ACC is not modified
########################################################################

negate:	0
	CLR C
	NEG dest
	JNR .+2
	DEC dest+1	; dest was 0
	COM dest+1	; double precision negate
	JMP @negate

########################################################################
#  double precision signed add
#	dest = dest + src
#	return double precision number in dest and dest+1
#	return truncated result in dest and dest+1 if overflow err message
########################################################################

add:	0
	LDA C40000
	AND dest+1
	STA sign	; sign bit of dest
	LDA C40000
	AND src+1
	CMP sign	; compare sign of dest with sign of src
	JEQ .+2
	INC sign	; sign of dest and src differ (no overflow)

	LDA dest	; double precision add dest + src
	CLR C
	ADD src
	STA dest
	LDA dest+1
	ADD src+1
	STA dest+1

	LDA C40000	; sign bit
	AND dest+1
	CLR C
	ADD C40000	; complement sign to make equal signs differ
	CMP sign	; no overflow if signs of dest and src differ or
	JNE @add	; sign of result equals sign of dest
	PRF errMsg	; "? err\n";
	JMP @add

########################################################################
#  double precision signed subtract
#	dest = dest - src
#	return double precision number in dest and dest+1
#	return truncated result in dest and dest+1 if overflow err message
########################################################################

sub:	0
	LDA C40000
	AND dest+1
	STA sign	; sign bit of dest
	LDA C40000
	AND src+1
	CMP sign	; compare sign of dest with sign of src
	JNE .+2
	INC sign	; sign of dest and src same (no overflow)

	LDA dest	; double precision subtract dest - src
	CLR C
	SUB src
	STA dest
	LDA dest+1
	SUB src+1
	STA dest+1

	LDA C40000	; sign bit
	AND dest+1
	CLR C
	ADD C40000	; complement sign to make equal signs differ
	CMP sign	; no overflow if signs of dest and src differ or
	JNE @sub	; sign of result equals sign of dest
	PRF errMsg	; "? err\n";
	JMP @sub

########################################################################
#  Test signs of dest and src for 'mul' and 'div' routines
#  If sign is negative for either value negate that value
#  If signs are the same set 'sign' = 0
#  If signs differ set 'sign' = 040000
########################################################################

setSgn:	0
	LDA C40000
	AND dest+1
	JZR setS1
	JMS negate	; ACC not modified
setS1:	STA sign	; sign bit of dest
	LDA C40000
	AND src+1
	JZR setS2
	CLR C
	NEG src
	JNR .+2
	DEC src+1	; src was 0
	COM src+1	; double precision negate src
setS2:	CLR C
	ADD sign	; sign dest ^ sign src
	STA sign
	JMP @setSgn

########################################################################
#  Test sign variable 'sign' set in 'setSgn'
#  If 'sign' is 0 do nothing
#  If 'sign' is 040000 negate dest, the result of mul or div
########################################################################

tstSgn:	0
	TST sign	; sign dest ^ sign src
	JZR @tstSgn	; positive result
	JMS negate	; negative result
	JMP @tstSgn

########################################################################
#  double precision signed multiply
#	dest = dest * src
#	return double precision number in dest and dest+1
#	return truncated result in dest and dest+1 if overflow
#	TODO - check for overflow
#  **** There is not enough room in the BALAD memory to do this check
#
#	sign = destHI ^ sign srcHI
#	negate dest if negative
#	negate src if negative
#				[   0  ]
#	+		[destHI][destLO]
#	*			[ srcLO]
#	=		[ ACC+1][   ACC]	carry over partial result in ACC+1
#			    |	    |
#			[   v  ]    |
#	+	[   0  ][destLO]    |
#	*		[ srcHI]    |
#	=	[ ACC+1][   ACC]    |		ACC+1 must be 0
#			    |	    |
#	negate if	    v	    v		sign destHI ^ sign srcHI	
#	=		[destHI][destLO]
########################################################################

mul:	0
	JMS setSgn	; test sign of dest and src
	LDA dest	; destLO
	STA mulcnd
	LDA dest+1	; destHI
	STA mulcnd+1
	LDA src		; srcLO
	STA mulplr
	CLR ACC
	JMS mult
	STA savACC	; save ACC

	LDA dest	; destLO
	STA mulcnd
	CLR mulcnd+1
	LDA src+1	; srcHI
	STA mulplr
	LDA savACC	; restore ACC
	STA dest	; reult in destLO is now fixed
	LDA ACC+1	; add result hi to next multiplication
	JMS mult
	STA dest+1	; result complete unless overflow

	JMS tstSgn	; negate dest if signs of dest and src differ
	JMP @mul

########################################################################
#  double precision signed divide
#	dest = dest / src
#	return double precision number in dest and dest+1
#	return unchanged if attempt to divide by 0
#
#  Since there is very little room left in the BALAD memory use this
#  very simple but slow algorithm:
#
#	Is divisor equal to 0 ?
#	Yes
#	    - Return divide by zero error
#	No
#	Set quotient = 0
#  lp:	Is the divisor (src) larger than the dividend (dest) ?
#	Yes
#	    -Return the remainder and the quotient
#	No
#	    -Subtract the divisor from the dividend
#	    -Increment the quotient by 1
#	    -Goto lp
########################################################################

div:	0
	TST src
	JNR div1
	TST src+1
	JNR div1
	PRF errMsg	; "? err\n";
	JMP @div	; return unchanged dest and src

div1:	JMS setSgn	; test sign of dest and src
	CLR quotit	; quotit = 0 (share with mulcnd)
	CLR quotit+1

div2:	LDA dest+1
	CMP src+1
	JLT div4
	JNE div3
	LDA dest	; dest+1 == src+1
	CMP src
	JLT div4	; return if dest < src

div3:	LDA dest	; double precision subtract dest - src
	CLR C
	SUB src
	STA dest
	LDA dest+1
	SUB src+1
	STA dest+1

	CLR C
	INC quotit
	JZC div2
	INC quotit+1
	JMP div2

div4:	LDA quotit	; remainder is in dest
	STA dest
	LDA quotit+1
	STA dest+1
	JMS tstSgn	; negate dest if signs of dest and src differ
	JMP @div

######  free for data  #################################################

expr:	0		; RPN expression filled upwards from here

######  Space for the expression and the stack  ########################

	LOC 776		; stack filled downwards from here
stack:	ADR prompt	; top of the stack (not overwritten via stackP)
			; 776 is also place for user defined prompt address

######  End of BALAD code  #############################################
__END__			; help text
  Reverse Polish Notation Calculator 'GEORGE'
        0-9     Enter a number terminated by white space or an operator,
                at which point the number is pushed on the stack.
        0-7     A number starting with 0 is octal (0-7 only).
        0-7 a-f A number starting with 0x is hexadecimal (0-9a-f).
        0-1     A number starting with 0b is binary (0-1 only).
        + - * / Arithmetic operators which act on the last two numbers
                popped from the stack. Result is pushed back on the stack.
                Error if there are less than two values on the stack.
        n       NEGATE the last number on the stack.
        Enter   display numbers on the stack as signed decimal.
        d       display numbers on the stack as signed decimal numbers
                before any further operations.
        o x b   display numbers on the stack in octal, hexadecimal or
                binary notation before any further operations.
        E       ENTER a number on the stack if 'E' immediately follows
                a number; else duplicate the last number on the stack.
        D       DROP the last number on the stack.
        S       SWAP the last two numbers on the stack.
        R       ROLL the stack - move last number to the top of the stack.
        C       CLEAR the stack.
        q       QUIT the RPN calculator.

        30 bit signed decimal arithmetic is used, which means all
        intermediate absolute values must be less than ~536 million.
        Arithmetic overflow errors for + and - are reported.
        Divide by zero and stack underflow errors are reported.

        There was not enough BALAD memory to check overflow for *
        the multiply operator and overflow of the stack into the area
        where the input expression is stored. 62 words are shared by
        these data structures. If they use half each, there is room for
        15 numbers on the stack at 2 words per number and an RPN
        expression of 63 characters at 2 characters per word.

        Also because of lack of memory the division algorithm is very
        simple and very slow. Division of 536,000,000 by 1 takes over
        an hour. For more reasonable numbers and larger divisors it works
        well. For the same reason there is no modulo division operator.
