#!/usr/bin/perl -w

########################################################################
#
#	Copyright (C) 2020  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the next line.
#
#	SPDX-License-Identifier: GPL-3.0+ OR Artistic-2.0
#
#	BALAD assembler, interpreter and debugger
#
#   Balad is an assembly level programming language for an emulated
#   virtual computer with a 15 bit word length. It is combined with a
#   comprehensive debugging system which allows on line program assembly,
#   execution of programs and the insertion of breakpoints to allow
#   suspension of programs during execution.
#
#   Instructions are machine oriented, using integer and logical
#   operations only. As a concession to the beginner extra instructions
#   are provided for single character, decimal number as well as text
#   string input and output. These facilities will enable students to
#   obtain reasonable displays of their results quickly, while
#   concentrating their efforts on developing algorithms.
#
########################################################################

use strict;
use integer;
use warnings;
use Term::ReadKey;
use Term::ReadLine;
$| = 1;				# output stdout buffer for every print or printf

########################################################################
#
#	Opcodes	- Hash used during assembly
#	    $opCodes{KEY}[0]	$instr ($op = $instr >> 10)
#	    $opCodes{KEY}[1]	may operate on carry for this KEY
#
########################################################################

my %opCodes = (    # $instr  c                       $instr  c            $op
	JMP	=> [ 000000, 1, ],	ADR	=> [ 000000, 1, ],	#  0
	JMS	=> [ 002000, 1, ],	# may not JMP to carry		#  1
	JZR	=> [ 004000, 1, ],	JEQ	=> [ 004000, 1, ],	#  2
	JNR	=> [ 006000, 1, ],	JNE	=> [ 006000, 1, ],	#  3

	JZC	=> [ 010000, 1, ],	JLT	=> [ 010000, 1, ],	#  4
	JNC	=> [ 012000, 1, ],	JGE	=> [ 012000, 1, ],	#  5
	JEZ	=> [ 014000, 1, ],	JLE	=> [ 014000, 1, ],	#  6
	JBN	=> [ 016000, 1, ],	JGT	=> [ 016000, 1, ],	#  7

	AND	=> [ 020000, 0, ],	# double operands can use carry	#  8
	ADD	=> [ 022000, 0, ],					#  9
	SUB	=> [ 024000, 0, ],					# 10
	CMP	=> [ 026000, 0, ],					# 11

	LDA	=> [ 030000, 0, ],	# may load carry		# 12
	STA	=> [ 032000, 0, ],	# may operate on carry		# 13
	CLR	=> [ 034000, 0, ],	# may operate on carry		# 14
	TST	=> [ 036000, 0, ],	# may test carry		# 15

	COM	=> [ 040000, 0, ],	# may complement carry		# 16
	NEG	=> [ 042000, 1, ],	# inhibit operation on carry	# 17
	INC	=> [ 044000, 1, ],					# 18
	DEC	=> [ 046000, 1, ],					# 19

	ROL	=> [ 050000, 1, ],					# 20
	ROR	=> [ 052000, 1, ],					# 21
	ASR	=> [ 054000, 1, ],					# 22
	SWP	=> [ 056000, 1, ],					# 23

	KDN	=> [ 060000, 1, ],					# 24
	KDD	=> [ 062000, 1, ],					# 25
	KCH	=> [ 064000, 1, ],					# 26
	KCS	=> [ 066000, 1, ],					# 27

	PDN	=> [ 070000, 0, ],	TDN	=> [ 070000, 0, ],	# 28  may print carry
	PDD	=> [ 072000, 1, ],	TDD	=> [ 072000, 1, ],	# 29
	PCH	=> [ 074000, 0, ],	TCH	=> [ 074000, 0, ],	# 30  may print carry
	PRF	=> [ 076000, 1, ],	TCS	=> [ 076000, 1, ],	# 31
);

########################################################################
#
#	Three arrays accessed by op code 0 - 31 (0 - 037)
#
#	    $opNames[op]	op code NAME for disassembly
#	    $opSubs[op]		op code subroutine reference
#	    $opTrace[op]	trace C ACC and [mem] for this op code
#	    $ocTrace[op]	trace C ACC and [mem] for instr before conditional jmp
#
#	These are implemented as four separate arrays for speed, since
#	@opSubs, @opTrace and @ocTrace are accessed for each instruction execution
#
########################################################################

my @opNames = ( # $instr $op
	"JMP",	# 000000  0
	"JMS",	# 002000  1
	"JZR",	# 004000  2
	"JNR",	# 006000  3
                           
	"JZC",	# 010000  4
	"JNC",	# 012000  5
	"JEZ",	# 014000  6
	"JBN",	# 016000  7
                           
	"AND",	# 020000  8
	"ADD",	# 022000  9
	"SUB",	# 024000 10
	"CMP",	# 026000 11
                           
	"LDA",	# 030000 12
	"STA",	# 032000 13
	"CLR",	# 034000 14
	"TST",	# 036000 15
                           
	"COM",	# 040000 16
	"NEG",	# 042000 17
	"INC",	# 044000 18
	"DEC",	# 046000 19
                           
	"ROL",	# 050000 20
	"ROR",	# 052000 21
	"ASR",	# 054000 22
	"SWP",	# 056000 23
                           
	"KDN",	# 060000 24
	"KDD",	# 062000 25
	"KCH",	# 064000 26
	"KCS",	# 066000 27
                           
	"PDN",	# 070000 28
	"PDD",	# 072000 29
	"PCH",	# 074000 30
	"PRF",	# 076000 31
);

my @opSubs = (  # $instr $op
	\&JMP,	# 000000  0
	\&JMS,	# 002000  1
	\&JZR,	# 004000  2
	\&JNR,	# 006000  3
                           
	\&JZC,	# 010000  4
	\&JNC,	# 012000  5
	\&JEZ,	# 014000  6
	\&JBN,	# 016000  7
                           
	\&AND,	# 020000  8
	\&ADD,	# 022000  9
	\&SUB,	# 024000 10
	\&CMP,	# 026000 11
                           
	\&LDA,	# 030000 12
	\&STA,	# 032000 13
	\&CLR,	# 034000 14
	\&TST,	# 036000 15
                           
	\&COM,	# 040000 16
	\&NEG,	# 042000 17
	\&INC,	# 044000 18
	\&DEC,	# 046000 19
                           
	\&ROL,	# 050000 20
	\&ROR,	# 052000 21
	\&ASR,	# 054000 22
	\&SWP,	# 056000 23
                           
	\&KDN,	# 060000 24
	\&KDD,	# 062000 25
	\&KCH,	# 064000 26
	\&KCS,	# 066000 27
                           
	\&PDN,	# 070000 28
	\&PDD,	# 072000 29
	\&PCH,	# 074000 30
	\&PRF,	# 076000 31
);

my @opTrace = ( # $instr $op
	0,	# 000000  0	JMP	no trace
	1,	# 002000  1	JMS	trace before and after execution
	0,	# 004000  2	JZR
	0,	# 006000  3	JNR
                                           
	0,	# 010000  4	JZC
	0,	# 012000  5	JNC
	0,	# 014000  6	JEZ
	0,	# 016000  7	JBN
                                           
	1,	# 020000  8	AND
	1,	# 022000  9	ADD
	1,	# 024000 10	SUB
	1,	# 026000 11	CMP
                                           
	1,	# 030000 12	LDA
	1,	# 032000 13	STA
	1,	# 034000 14	CLR
	1,	# 036000 15	TST
                                           
	1,	# 040000 16	COM
	1,	# 042000 17	NEG
	1,	# 044000 18	INC
	1,	# 046000 19	DEC
                                           
	1,	# 050000 20	ROL
	1,	# 052000 21	ROR
	1,	# 054000 22	ASR
	1,	# 056000 23	SWP
                                           
	1,	# 060000 24	KDN
	1,	# 062000 25	KDD
	1,	# 064000 26	KCH
	1,	# 066000 27	KCS
                                           
	0,	# 070000 28	PDN
	0,	# 072000 29	PDD
	0,	# 074000 30	PCH
	0,	# 076000 31	PRF
);

my @ocTrace = ( # $instr $op
	0,	# 000000  0	JMP
	0,	# 002000  1	JMS
	1,	# 004000  2	JZR	trace instruction before conditional jmp
	1,	# 006000  3	JNR
                                           
	1,	# 010000  4	JZC
	1,	# 012000  5	JNC
	1,	# 014000  6	JEZ
	1,	# 016000  7	JBN
                                           
	0,	# 020000  8	AND
	0,	# 022000  9	ADD
	0,	# 024000 10	SUB
	0,	# 026000 11	CMP
                                           
	0,	# 030000 12	LDA
	0,	# 032000 13	STA
	0,	# 034000 14	CLR
	0,	# 036000 15	TST
                                           
	0,	# 040000 16	COM
	0,	# 042000 17	NEG
	0,	# 044000 18	INC
	0,	# 046000 19	DEC
                                           
	0,	# 050000 20	ROL
	0,	# 052000 21	ROR
	0,	# 054000 22	ASR
	0,	# 056000 23	SWP
                                           
	0,	# 060000 24	KDN
	0,	# 062000 25	KDD
	0,	# 064000 26	KCH
	0,	# 066000 27	KCS
                                           
	1,	# 070000 28	PDN	trace instruction before print instructions
	1,	# 072000 29	PDD
	1,	# 074000 30	PCH
	0,	# 076000 31	PRF	leave out print string
);

my @mem		= (0) x 01001;	# BALAD memory 0 - 777 initialised to 0 (HLT)
my @breaks	= (0) x 01001;	# BALAD breaks 0 - 777 initialised to 0
my $break	= 0;		# break at every instuction step when set
my $running	= 0;		# 0 not running 1 running not at break point 2 running at break
my $jmsCall	= 0;		# address of current JMS subroutine
my @jmsStack	= ();		# stack of JMS calls
my %comments	= ();
my %symTable	= ( ACC => 0, C => 0777 );	# define names of accumulator and carry
my %symbols	= ( 0 => "ACC", 511 => "C" );	# define inverse symbols
my %cntrl_slash	= (		# forward control character translation
	"\a"	=> "\\a",	# BEL	alarm
	"\b"	=> "\\b",	# BS	back space
	"\t"	=> "\\t",	# HT	horizontal tab
	"\n"	=> "\\n",	# LF	new line
	"\f"	=> "\\f",	# FF	form feed
	"\r"	=> "\\r",	# CR	carriage return
	"\e"	=> "\\e",	# ESC
);
my %ascii_cntrl	= (		# inverse translation ascii following '\'
	"a"	=> "\a",	# BEL	alarm
	"b"	=> "\b",	# BS	back space
	"t"	=> "\t",	# HT	horizontal tab
	"n"	=> "\n",	# LF	new line
	"f"	=> "\f",	# FF	form feed
	"r"	=> "\r",	# CR	carriage return
	"e"	=> "\e",	# ESC
);
my @debPrompts	= ( ">>", "B>", "W>" );			# debug() entry prompts

my $named = $0;
$named =~ s#.*[/\\]##;		# delete directory names in path
my @argv = ();
my @argv2 = ();
my ($argv,$loc, $state, $pc, $mr, $tmp, $jtA, $jtC, $listMode, $listOfs, $abort, $cmr);

format STDERR =
Usage:  @<<<<[ -l[doxb]cm][ <source_file> ...]|[ -h]
        $named
        -l      list code output during assembly and execution
          -d    additionally list C, ACC and MR in decimal
          -o    additionally list C, ACC and MR in octal
          -x    additionally list C, ACC and MR in hexadecimal
          -b    additionally list C, ACC and MR in binary
                in each case show values before and after execution
            can also be applied at run time as debug commands
        -c      assembly only - no execution
        -m      show execution time in microsecond resolution
        -h      help, ouput this Usage text only
        <source_file>  one or more balad source files (ext .bl).
        Any file with ext .lst is interpreted as a list of files.
$Id: balad 1.3 $

        After successful assembly the program starting at 'main' 
        if defined is run - else enter the Debugger (prompt >>).
        If there is no <source> file enter code interactively.

.

format STDOUT =
 Debugger
    Locations <n> or <m> may be an octal number or
        a defined address label [+/- a decimal offset] or
        . [+/- a decimal offset], where . is the current location

 >> enter a debug command when program is not running
        The run or enter command can only be called at >>
    r      run code from address 'main' if defined - else 0100
    <n>r   run code from address <n>
    e      enter new or revised code or data interactively
           terminate entry with key q or ctrl D (EOF)

 B> enter a debug command at a break point
 W> enter a debug command at a watch point
        The following commands can only be called at a break
        or watch point of an interrupted running program
    s      STEP to next instruction, entering into JMS subroutines
    n      execute NEXT instruction skipping over JMS subroutines
    u      continue execution UNTIL leaving current subroutine
    c      CONTINUE execution until next break or watch point
    a      abort the current program - allow new run or enter

        All other commands can be called in either mode.
    q         QUIT balad
    h         output this HELP text
    *         set a BREAK or watch point at current location
    <n>*      set a BREAK or watch point at location <n>
    <n>,<m>*  set BREAK or watch points at locations <n> to <m>
    #         CLEAR all break or watch points
    .#        CLEAR a break or watch point at current location
    <n>#      CLEAR a break or watch point at location <n>
    <n>,<m>#  CLEAR break or watch points at locations <n> to <m>
    =         list all break or watch points in current list mode
    <n>,<m>=  list break or watch points in range <n> to <m>
    < <code>  assemble <code> or <data> at current location
    <n>< <code>  assemble <code> or <data> at location <n>

        List commands show an octal memory address and the contents
    /c        list code at current location
    <n>/c     list code at location <n>
    <n>,<m>/c list code at locations <n> to <m>

        Similarly for different list modes
    /d    short signed decimal       /D    long signed decimal  
    /u    short unsigned decimal     /U    long unsigned decimal
    /o    short unsigned octal       /O    long unsigned octal
    /x    short unsigned hexadecimal /X    long unsigned hexadecimal
    /b    short unsigned binary      /B    long unsigned binary
    /s    text string up to next NULL
        these apply to all other commands starting at * (set a BREAK)
    / or enter    list location(s) in current list mode

    -     stop listing code output during execution
    -l    list code output during execution
      -d  additionally  trace C, ACC and MR in decimal
      -o  alternatively trace C, ACC and MR in octal
      -x  alternatively trace C, ACC and MR in hexadecimal
      -b  alternatively trace C, ACC and MR in binary
          In each case trace values before and after execution.
          Without -l trace only at break or watch points.
.

use vars qw($opt_l $opt_o $opt_d $opt_x $opt_b $opt_c $opt_m $opt_T $opt_h);
use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    '<>'  => sub { push(@argv, @_); },	# Transfer file argument to @argv
    'l'   => \$opt_l,
    'o'   => \$opt_o,
    'd'   => \$opt_d,
    'x'   => \$opt_x,
    'b'   => \$opt_b,
    'c'   => \$opt_c,
    'm'   => \$opt_m,
    'T'   => \$opt_T,
    'h'   => \$opt_h,
);
my $optlx =  $opt_l && ($opt_o || $opt_d || $opt_x || $opt_b);
my $optnx = !$opt_l && ($opt_o || $opt_d || $opt_x || $opt_b);
my ($opttx, $traceFormat);
if ($opt_o) {
    $traceFormat = "%sC %d ACC %05o [%03o] %05o";	# octal has precedence
} elsif ($opt_d) {
    $traceFormat = "%sC %d ACC %5d [%03o] %5d";
} elsif ($opt_x) {
    $traceFormat = "%sC %d ACC %04x [%03o] %04x";
} elsif ($opt_b) {
    $traceFormat = "%sC %d ACC %015b [%03o] %015b";
}

if ($opt_h) {
    write STDERR; write STDOUT; exit 0;	# -h, ouput Usage only
}

if ($opt_m) {
    use Time::HiRes qw(gettimeofday);
}

my $eF = 0;
my $term = Term::ReadLine->new('balad');
$SIG{QUIT} = \&interrupt;	# signal 3	(ctrl-\ interrupt from keyboard)
$SIG{PIPE} = \&interrupt;	# signal 13

# Pass 1 - process labels only
my $filesAssd	= 0;		# number of BALAD source files assembled
$loc = 0100;			# first default location
while ($argv = shift @argv) {
    unless (open (IN, $argv)) {
	warn "can't open input file $argv";
	next;
    }
    if ($argv =~ /\.lst$/) {	# x.lst is a list of filenames
	while (<IN>) {		# read next entry from x.lst into $_
	    chomp;		# $_ is a filname entry out of x.lst
	    push(@argv, $_);	# put next filename on end of @argv
	}
    } else {
	push(@argv2, $argv);	# file list for pass 2
	$eF += assembleFile(1);	# Pass 1
	$filesAssd++;
    }
    close(IN);
}

# Pass 2 - full assembly
$loc = 0100;			# first default location
while ($argv = shift @argv2) {
    unless (open (IN, $argv)) {
	warn "can't open input file $argv";
	next;
    }
    print STDERR "$argv\n" if $filesAssd >= 2;
    $eF += assembleFile(2);	# Pass 2
    close(IN);
}

if ($eF) {
    my $s = $eF >= 2 ? "s" : "";
    warn "*** ERROR: $eF error$s during assembly - cannot run\n";
} elsif (not $opt_c) {
    ########################################################################
    #   Enter run and debugging commands
    ########################################################################
    $loc = 0100;		# first default location
    $listMode = 'c';		# list code initially
    $listOfs  = 1;		# list offset is 1
    debug(0);
}
### End of Perl main ########################################################

########################################################################
#
#	Catch and report stray signals
#
########################################################################

sub interrupt {
    my $signame = shift;
    if ($signame =~ /^QUIT/) {
	$break = 1 if $running == 1;
    } else {
	die "$named: Caught SIG$signame: $!";
    }
} # catch_zap

########################################################################
#
#  Convert a BALAD string to a PERL string
#	$string = convString($memr, $vis)
#	parameter1	memref of BALAD string
#	parameter2	0 raw; 1 vis \t \n etc (default raw)
#	return		perl string
#	$cmr - global	memref of BALAD word after string
#
########################################################################

sub convString {
    my ($memr, $vis) = @_;
    my ($mval, $byte, $ch, $st);
    my @nums = ();
    for ($cmr = $memr; ; $cmr++) {
	$mval = $mem[$cmr];
	last if ($byte = $mval & 0177) == 0;
	$ch = chr $byte;
	push @nums, $vis && defined($st = $cntrl_slash{$ch}) ? $st : $ch;
	last if ($byte = ($mval & 077400) >> 8) == 0;
	$ch = chr $byte;
	push @nums, $vis && defined($st = $cntrl_slash{$ch}) ? $st : $ch;
    }
    $st = join "", @nums;	# build string
    return $st;			# global $cmr returns memory ref of word after string
} # convString

########################################################################
#
#	Typical BALAD assembler language code
#
#	When 'balad' is first started, all locations 0 to 777 are set to 00000
#	which means they are all HLT instructions.
#	If pre-tested routines are to be entered from files, they should
#	be listed as arguments to the 'balad' command:
#	    balad multply.bal divide.bal double.bal
#	After the last file interactive debug mode is entered and more code
#	may be added with the 'e' command, which enters interactive entry mode.
#
#	In interactive mode the first column of octal numbers are output
#	by the assembler (input from stdin, not from a file).
#	Labels are followed by a colon (:) and are optional.
#	White space can be 1 or more spaces or tabs.
#	When a program is run with the r command (no address), it starts
#	at 'main'. Alternatively use 100r to start this program.
#	Either way the Acummulator (LOC 0) and Carry (LOC 777) are cleared.
#
#		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#		;
#		;	Comment block
#		;
#		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#
#		LOC	10	; initialised data block
# 010	op1:	99
# 011	op2:	81
# 012	sum:	BLK	1	; uninitialised data block
# 013
#		LOC	100	; code block
# 100	main:	CLR	C	; clear carry before addition
# 101		LDA	op1
# 102		ADD	op2
# 103		STA	sum
# 104		PDN	sum
# 105		HLT
#
########################################################################

sub assembleFile {
    my ($pass) = @_;		# pass 0 interactive, pass 1 defined labels, pass 2 finish file assembly
    my $eFlg = 0;
    print "Enter LOC and code or data interactively (q to return to debugger)\n\n	" if $pass == 0;
    $state = 0;			# 0 none  1 data  2 code
    while (<IN>) {
	chomp;							# remove new line
	last if m/^\s*q$/;					# quit assembly
	$eFlg += assembleLine($pass, $_);			# assemble a line
    }
    return $eFlg;
} # assembleFile

########################################################################
#  Allow assembly of single lines called from debug() in pass 0
########################################################################

sub assembleLine {
    no warnings;
    no warnings 'deprecated';
    my ($pass, $newLoc);
    ($pass, $_, $newLoc) = @_;
    my ($label, $op, $num, $dval, $val, $locn, $blk, $str);
    my ($comment, $i, $bs, $char, $byte, $char0, $byte0);
    my $errFlag = 0;
    $locn = $blk = $str = $dval = $val = undef;
    s/[ \t]+$//;						# remove trailing spaces and tabs
    $label = $comment = '';
    if (defined $newLoc and $loc != $newLoc) {
	$loc = $newLoc;						# one line assembly from debug
	$state = 1;						# allow data or code line
    }
    ## label common to all types of statements #############################
    if (m/^\s*([A-Za-z]\w*)\s*:/g) {
	if (not defined ($num = $symTable{$1})) {
	    $symTable{$1} = $num = $loc;			# define symbolic reference
	    $symbols{$loc} = $1;				# inverse symbols for disassembly listing
	} elsif ($pass != 1 and $num != $loc) {
	    $tmp = sprintf "trying to redefine symbolic reference '%s' to %o from %o", $1, $loc, $num;
	    warn "			$_\n*** ERROR: $tmp\n";
	    $errFlag++;
	}
	$label = "$1:" if $num == $loc;				# for listing of "string"
    }
    ## code statement starting with an OP code followed by a MR ############
    if (m/\G \s*
	    ( [A-Z]+ ) \s*			# $1	op code
	    (					# $2	optional memory reference - default 0 ACC
		(				# $3
		    (@?) \s*			# $4	optional @ for indirect MR
		)
		(				# $5
		    ( [0-7]+ )			# $6	octal MR
		    |				#	or
		    (				# $7
			(			# $8
			    ( [A-Za-z]\w* )	# $9	symbolic MR label
			    |			#	or
			    ( \. )		# $10	current location for relative MR
			)
			( \s*			# $11	optional
			    ( [+-] )? \s*	# $12	sign - missing is error
			    ( \d+  )		# $13	decimal offset
			)?
		    )
		)
	    )?
	    ( \s* [;#].* )?			# $14	optional comment
	$/x and
	defined($op = $opCodes{$1}[0]) ) {
	$num = 0;
	if ($2) {
	    if (defined $6) {
		$num = oct($6);					# octal memory reference
	    } else {
		if (defined $9) {
		    if (defined($tmp = $symTable{$9})) {	# symbolic memory reference
			$num = $tmp;
		    } elsif ($pass != 1) {
			$tmp = sprintf "%o", $loc;
			warn "			$_\n*** ERROR: symbolic reference '$9' at loc $tmp has not been defined\n";
			$errFlag++;
		    }
		} elsif (defined $10) {
		    $num = $loc;				# "." relative memory reference
		}
		if (defined $11) {
		    goto SynErr0 unless $12;
		    if ($12 eq "-") {
			$num -= $13;				# negative offset
		    } else {
			$num += $13;				# positive offset
		    }
		}
	    }
	    if ($pass != 1 and (($num &= 077777) >= (($opCodes{$1}[1] || $4) ? 0777 : 01000))) {
		$tmp = sprintf "mr %o is illegal %s at loc %o", $num, $num eq 0777 ? "carry" : "memory reference", $loc;
		warn "			$_\n*** ERROR: $tmp\n";
		$errFlag++;
		goto Retry;
	    }
	}
	$val = $op | ($4 ? 01000 : 0) | $num;			# BALAD code statement
	$comment = $14;
	$state = $op ? 2 : 1;					# follow with code or data if JMP
    ## HLT statement #######################################################
    } elsif (m/\G(\s*HLT)(\s*[;#].*)?$/) {
	$val = 0;						# code HLT (JMP 0)
	$comment = $2;
	$state = 1;						# end of code block
    ## blank line or comment in a code block ###############################
    } elsif ($state == 2 and m/\G(\s*[;#].*)?$/) {
	$comment = $1;						# blank line or comment in code (no state change)
    } elsif ($state <= 1) {
	## LOC statement #######################################################
	if (m/\G\s*LOC\s*([0-7]+)(\s*[;#].*)?$/) {
	    $num = oct $1;					# LOC statement	(octal argument)
	    goto TestLOC;
	## BLK statement #######################################################
	} elsif (m/\G\s*BLK\s*([1-9][0-9]*)(\s*[;#].*)?$/) {
	    $blk = $num = $loc + $1;				# BLK statement (decimal argument)
	  TestLOC:
	    $comment = $2;
	    if ($pass != 1 and ($num <= 0 or $num >= 0777)) {
		$num = sprintf "%o", $num;
		warn "			$_\n*** ERROR: LOC $num; 0 and 777 are reserved, > 777 is illegal\n";
		$errFlag++;
		goto Retry;
	    } elsif ($pass >= 1 and $mem[$num]) {
		$num = sprintf "%o", $num;
		goto MemERR2;		# LOC already initialised
	    } else {
		$locn = $num;		# LOC 02 to 0776
		$state = 1;
	    }
	## unsigned decimal number #############################################
	} elsif (m/\G\s*([1-9][0-9]*)([lL]?)(\s*[;#].*)?$/) {
	    $num = $1;						# unsigned decimal number
	    goto TestNUM;
	## octal, hexadecimal or binary number #################################
	} elsif (m/\G\s*(0[0-7]*)([lL]?)(\s*[;#].*)?$/ or	# octal number
		 m/\G\s*(0[xX][0-9a-fA-F]+)([lL]?)(\s*[;#].*)?$/ or # hexadecimal number
		 m/\G\s*(0[bB][01]+)([lL]?)(\s*[;#].*)?$/) {	# binary number
	    $num = oct $1;
	  TestNUM:
	    $comment = $3;
	    if ($2) {
		if ($num <= 07777777777) {
		    $val  = $num & 077777;			# long number
		    $dval = ($num >> 15) & 077777;
		} elsif ($pass != 1) {
		    warn "			$_\n*** ERROR: unsigned long number must be less than 1,073,741,824 (10000000000 octal)\n";
		    $errFlag++;
		    goto Retry;
		}
	    } else {
		if ($num <= 077777) {
		    $val  = $num;				# short number
		} elsif ($pass != 1) {
		    warn "			$_\n*** ERROR: unsigned short number must be less than 32,768 (100000 octal)\n";
		    $errFlag++;
		    goto Retry;
		}
	    }
	## signed decimal number ###############################################
	} elsif (m/\G\s*([-+])([1-9][0-9]*)([lL]?)(\s*[;#].*)?$/) {
	    $num = $2;						# signed decimal number
	    $comment = $4;
	    if ($3) {
		if ($num <= 03777777777) {			# long number
		    $num  =  -$num & 07777777777 if $1 eq '-';
		    $val  = $num & 077777;
		    $dval = ($num >> 15) & 077777;
		} elsif ($pass != 1) {
		    warn "			$_\n*** ERROR: absolute value of long signed number must be less than 536,870,912 (4000000000 octal)\n";
		    $errFlag++;
		    goto Retry;
		}
	    } else {
		if ($num <= 037777) {				# short number
		    $val  = $1 eq '-' ? -$num & 077777 : $num;
		} elsif ($pass != 1) {
		    warn "			$_\n*** ERROR: absolute value of short signed number must be less than 16,384 (40000 octal)\n";
		    $errFlag++;
		    goto Retry;
		}
	    }
	## character "string" ##################################################
	} elsif (m/\G\s*"(.*)"(\s*[;#].*)?$/) {
	    $str  = $1;						# character string
	    $comment = $2;
	## blank line or comment in a data block ###############################
	} elsif (m/\G(\s*([;#].*)?)?$/) {
	    $comment = $1;					# blank line or comment only
	    $state   = 0;
	## data not recognised #################################################
	} elsif ($pass != 1) {
	  SynErr0:
	    warn "			$_\n*** ERROR: syntax error - code or data not recognised\n";
	    $errFlag++;
	    goto Retry;
	}
    ## code not recognised or improper code block termination ##############
    } elsif ($pass != 1) {
	$num = sprintf "%o", $loc;
	warn "			$_\n*** ERROR: syntax error or code block not terminated by a JMP or HLT instruction at loc $num\n";
	$errFlag++;
	goto Retry;
    }
    ########################################################################
    #   End of one input line
    ########################################################################
    if (($opt_l and $pass != 1) or defined $newLoc) {
	########################################################################
	#   Optionally list code or data produced - check for address error
	########################################################################
	print "==>" if defined $newLoc;				# for call from debug()
	if (defined $val) {					# code or short number
	    if ($loc > 0777 or ($pass >= 1 and $mem[$loc])) { goto MemERR0; }
	    printf "	%03o	%05o	%s\n", $loc, $val, $_;
	    if (defined $dval) {				# long double precision number
		if ($loc + 1 > 0777 or ($pass >= 1 and $mem[$loc + 1])) { $loc++; goto MemERR0; }
		printf "	%03o	%05o	(%#o)\n", $loc + 1, $dval, ($dval << 15) + $val;
	    }
	} elsif (defined $str) {				# string
	    $char0 = '';
	    $byte0 = $bs = $i = 0;
	    foreach $char (split //, $str) {
		$byte = ord $char;
		if ($bs) {
		    if (defined($tmp = $ascii_cntrl{$char})) {
			$char = $cntrl_slash{$tmp};		# "\n" => "\\n" should be defined
			die "*** internal error - cntrl_slash hashes not correct ???" unless defined $char;
			$byte = ord $tmp;			# \ n  => "\n"  etc
		    }
		} elsif ($char eq "\\") {
		    $bs = 1;
		    next;
		}
		$bs = 0;					# all other chars following '\' unchanged
		$char = $tmp if defined ($tmp = $cntrl_slash{$char});	# "\n" => "\\n"
		if ($byte0) {
		    if ($loc + $i > 0777 or ($pass >= 1 and $mem[$loc + $i])) { $loc += $i; goto MemERR0; }
		    if ($i == 0) {
			printf "\t%03o\t%05o\t%s\t%s %s\t\"%s\"\n", $loc + $i++, (($byte & 0177) << 8) + ($byte0 & 0177), $label, $char0, $char, $str;
		    } else {
			printf "\t%03o\t%05o\t\t%s %s\n", $loc + $i++, (($byte & 0177) << 8) + ($byte0 & 0177), $char0, $char;
		    }
		    $byte0 = 0;
		    $char0 = '';
		} else {
		    $byte0 = $byte;
		    $char0 = $char;
		}
	    }
	    if ($loc + $i > 0777 or ($pass >= 1 and $mem[$loc + $i])) { $loc += $i; goto MemERR0; }
	    if ($i == 0) {
		printf "\t%03o\t%05o\t%s\t%s\t\"%s\"\n", $loc + $i, ($byte0 & 0177), $label, $char0, $str;
	    } else {
		printf "\t%03o\t%05o\t\t%s\n", $loc + $i, ($byte0 & 0177), $char0;
	    }
	} elsif (defined $blk) {
	    printf "	%03o		%s\n", $loc, $_;
	} else {
	    printf "			%s\n", $_;		# all other lines
	}
	if ($comment) {
	    $comments{$loc} .= "$comment\n";
	    $comment = '';
	}
    }
    ########################################################################
    #   Store code or data in memory - check for address error
    #   This section is missed if optional listing found an error
    ########################################################################
    if (defined $val) {						# single word of code or numeric data
	if ($loc > 0777 or ($pass >= 1 and $mem[$loc])) { goto MemERR1; }
	$mem[$loc] = $val if $pass != 1;
	$loc++;
	if (defined $dval) {					# high order word of numeric data
	    if ($loc > 0777 or ($pass >= 1 and $mem[$loc])) { goto MemERR1; }
	    $mem[$loc] = $dval if $pass != 1;
	    $loc++;
	}
    } elsif (defined $str) {					# "character string" (may be more than 1 word)
	$byte0 = $bs = $i = 0;
	foreach $char (split //, $str) {
	    $byte = ord $char;
	    if ($bs) {
		if (defined($tmp = $ascii_cntrl{$char})) {
		    $byte = ord $tmp;				# \ n  => "\n"  etc
		}
	    } elsif ($char eq "\\") {
		$bs = 1;
		next;
	    }
	    $bs = 0;						# all other chars following '\' unchanged
	    if ($byte0) {
		if ($loc > 0777 or ($pass >= 1 and $mem[$loc])) { goto MemERR1; }
		$mem[$loc] = (($byte & 0177) << 8) + ($byte0 & 0177) if $pass != 1;
		$loc++;
		$byte0 = 0;
	    } else {
		$byte0 = $byte;
	    }
	}
	if ($loc > 0777 or ($pass >= 1 and $mem[$loc])) { goto MemERR1; }
	$mem[$loc] = ($byte0 & 0177) if $pass != 1;
	$loc++;
    } elsif (defined $locn) {
	$loc = $locn;						# no data stored
    }
    goto Retry;
  MemERR0:
    print "\n";
  MemERR1:
    $byte0 = 0;
    $num = sprintf "%o", $loc;
  MemERR2:
    warn "			$_\n*** ERROR: LOC $num illegal or already initialised with code or data\n";
    $errFlag++;
  Retry:
    $locn = $blk = $str = $dval = $val = undef;
    if ($pass == 0 and not defined $newLoc) {
	if ($state == 0) {
	    printf "	";
	} else {
	    printf "%03o	", $loc;
	}
    }
    use warnings 'deprecated';
    use warnings;
    return $errFlag;
} # assembleLine

########################################################################
#
#  Debugger
#    arg1: 0 called before running a program
#	   1 called from a break
#	   2 called from a watch point
#
#    Locations <n> or <m> may be an octal number or
#	a defined address label [+/- a decimal offset] or
#	. [+ or/ decimal offset], where . is the current location
#
#    >> enter a debug command when program is not running
#		The run or enter command can only be called at >>
#		when arg1 == 0.
#	r	   run code from address 'main' if defined - else 0100
#	<n>r	   run code from address <n>
#	e	   enter new or revised code or data interactively
#		   terminate entry with key q or ctrl-D (EOF)
#
#    B> enter a debug command at a break point
#    W> enter a debug command at a watch point
#		The following commands can only be called at a break
#		or watch point of an interrupted running program
#		when arg1 >= 1
#	s	   STEP to next instruction, entering into JMS subroutines
#	n	   execute NEXT instruction skipping over JMS subroutines
#	u	   continue execution UNTIL leaving current subroutine
#	c	   CONTINUE execution until next break or watch point
#	a	   abort the current program - allow new run or enter
#
#		All other commands can be called in either mode.
#	q	   QUIT balad
#	h	   output this HELP text
#	*	   set a BREAK or watch point at current location
#	<n>*	   set a BREAK or watch point at location <n>
#	<n>,<m>*   set BREAK or watch points at locations <n> to <m>
#	#	   CLEAR all break or watch points
#	.#	   CLEAR a break or watch point at current location
#	<n>#	   CLEAR a break or watch point at location <n>
#	<n>,<m>#   CLEAR break or watch points at locations <n> to <m>
#	=	   list all break or watch points in current list mode
#	<n>,<m>=   list break or watch points in range <n> to <m>
#	< <code>   assemble <code> or <data> at current location
#	<n>< <code>  assemble <code> or <data> at location <n>
#
#		List commands show an octal memory address and the contents
#	/c	   list code at current location
#	<n>/c	   list code at location <n>
#	<n>,<m>/c  list code at locations <n> to <m>
#
#		Similarly for different list modes
#	/d	   list short signed decimal
#	/u	   list short unsigned decimal
#	/o	   list short unsigned octal
#	/x	   list short unsigned hexadecimal
#	/b	   list short unsigned binary
#	/D	   list long signed decimal
#	/U	   list long unsigned decimal
#	/O	   list long unsigned octal
#	/X	   list long unsigned hexadecimal
#	/B	   list long unsigned binary
#	/s	   list text string up to next NULL
#		these apply to all other commands starting at * (set a BREAK)
#	/  or enter    list location(s) in current list mode
#
#	-	stop listing code output during execution
#	-l	list code output during execution
#	  -d	additionally  trace C, ACC and MR in decimal
#	  -o	alternatively trace C, ACC and MR in octal
#	  -x	alternatively trace C, ACC and MR in hexadecimal
#	  -b	alternatively trace C, ACC and MR in binary
#		In each case trace values before and after execution.
#		Without -l trace only at break or watch points.
#
########################################################################

sub debug {
    my ($mode, $op, $mr) = @_;
    my ($listCmd, $lstart, $lfin, $l, $brkStar, $label, $sym, $stFlag, $num, $assIn);
    $running = 2 if $running;			# stop interrupt with ctrl-\ key in debug
    if ($mode == 0) {
	if ($filesAssd != 0) {
	    if (defined($tmp = $symTable{'main'}) and not $opt_l) {
		########################################################################
		#  No essmbly errors in file(s) - run if main: defined and not -l
		########################################################################
		$pc = $loc = $tmp;		# start location defined in the assembled program
		run();				# run the code immediately
		exit() unless $abort;
	    } else {
		########################################################################
		#  else enter debugger
		########################################################################
		$loc = $tmp if defined $tmp;
		print "BALAD debugger - enter r to run code at 0100, e to enter more code interactively\n";
	    }
	} else {
	    ########################################################################
	    #  BALAD called without file argements - enter code for interactive assembly
	    ########################################################################
	    unless (open (IN, "-")) {		# STDIN	- no source file arguments
		die "can't open STDIN ???";
	    }
	    $argv = "-";			# enter first code or data
	    assembleFile(0);			# interactive pass 0
	    close(IN);
	    print("\n");
	}
    }
    ########################################################################
    #  entered debug proper after assembly or from a break or watch point
    ########################################################################
  Input:
    while (defined($tmp = sprintf "%03o %s ", $loc, $debPrompts[$mode]) and	# always true
	defined($_ = $term->readline("$tmp"))) {
	if ($mode == 0) {
	    if (m/^\s*e(nter)?$/) {		# enter command (must be first - otherwise label 'e')
		########################################################################
		#  enter more code or data
		########################################################################
		unless (open (IN, "-")) {	# STDIN
		    die "can't open STDIN ???";
		}
		$argv = "-";
		assembleFile(0);		# interactive pass 0
		close(IN);
		print("\n");
		next;
	    }
	    if (m/^ \s*
		(					# $1	optional
		    (					# $2	address
			( [0-7]+ )			# $3	octal MR
			|				#	or
			(				# $4
			    (				# $5
				( [A-Za-z]\w* )		# $6	symbolic MR label
				|			#	or
				( \. )			# $7	current location for relative MR
			    )
			    ( \s*			# $8	optional
				( [+-] ) \s*		# $9	sign - missing is error
				( \d+  )		# $10	decimal offset
			    )?
			)
		    ) \s*
		)?  r(un)?				# $11	 run command
	    $/x) {
		########################################################################
		#  r         run BALAD code from default start address is main: or 0100
		#  <octal>r  run BALAD code from octal address
		#  <label>r  run BALAD code from a symbolic address
		#  .+/-<n>r  run BALAD code from a relative address
		########################################################################
		if (not $1) {
		    $num = defined($tmp = $symTable{'main'}) ? $tmp : 0100;	# default start address
		} elsif (defined $3) {
		    $num = oct($3);			# octal memory reference
		} else {
		    if (defined $6) {
			if (defined($tmp = $symTable{$6})) {# symbolic memory reference
			    $num = $tmp;
			} else {
			    warn "??? symbolic reference '$6' has not been defined\n";
			    next;
			}
		    } elsif (defined $7) {
			$num = $loc;			# "." relative memory reference
		    }
		    if (defined $8) {
			if ($9 eq "-") {
			    $num -= $10;		# negative offset
			} elsif ($9 eq "+") {
			    $num += $10;		# positive offset
			}
		    }
		}
		$pc = $num;
		run();
		next;
	    }
	} else {
	    ########################################################################
	    #  entered from break in executing code (mode >= 1)
	    #	s	step one instruction	- into JMS subroutine
	    #	n	next instruction	- skip over JMS subroutine
	    #	u	until return out of current JMS subroutine
	    #	c	continue until next break or watch point
	    #	a	abort execution		- stop program running
	    ########################################################################
	    $break = 0;
	    if (m/^\s*([snuca])$/) {
		if ($1 eq 's') {		# single step
		    $break = 1;
		} elsif ($1 eq 'n') {		# next unless JMS at a break point
		    if ($op != 01 or $mode != 1) {
			$break = 1;
		    } else {
			$jmsCall = $mr;		# defer breaks until return from this JMS
		    }
		} elsif ($1 eq 'u') {		# run until return from current JMS
		    $jmsCall = $jmsStack[$#jmsStack] if scalar @jmsStack;
		} elsif ($1 eq 'a') {		# abort execution
		    $abort = 1;
		}
		goto stopDebug;			# continue ('c' is none of the above)
	    } elsif (m/((r(un)?)|(e(nter)?))$/) {
		$tmp = $2 ? "run" : "enter";
		$sym = $mode == 1 ? "break" : "watch";
		warn "??? cannot $tmp a program from a $sym point - exit first with 'a'\n";
		next;
	    }
	}
	########################################################################
	#  rest can be called in all modes
	#  optional address or address range for all following debug commands
	########################################################################
	if (m/^\s*q(uit)?$/) {
	    exit;				# quit BALAD (must be first - otherwise label 'q')
	}
	if (m/^\s*h(elp)?$/) {	
	    ########################################################################
	    #  output help text
	    ########################################################################
	    write STDOUT;
	    next;
	}
	if (m/^
	    (   \s*				# $1  optional address
		(				# $2  start of range
		    ( [0-7]+ )			# $3	octal MR
		    |				#	or
		    (				# $4
			(			# $5
			    ( [A-Za-z]\w* )	# $6	symbolic MR label
			    |			#	or
			    ( \. )		# $7	current location for relative MR
			)
			( \s*			# $8	optional
			    ( [+-] ) \s*	# $9	sign - missing is error
			    ( \d+  )		# $10	decimal offset
			)?
		    )
		)
		(   \s*,\s*			# $11 optional
		    (				# $12 end of range
			( [0-7]+ )		# $13	octal MR
			|			#	or
			(			# $14
			    (			# $15
				( [A-Za-z]\w* )	# $16	symbolic MR label
				|		#	or
				( \. )		# $17	current location for relative MR
			    )
			    ( \s*		# $18	optional
				( [+-] ) \s*	# $19	sign - missing is error
				( \d+  )	# $20	decimal offset
			    )?
			)
		    )
		)?
	    )?  \s*
	    (				# $21 optional empty command (list)
		( [*#=<\/] )		# $22 command selection
		( [cduoxbDUOXBsS] )?	# $23 optional list mode selection
		( .* )			# $24 optional assembly input
	    )?
	$/x) {
	    ########################################################################
	    #  act on or list 1 or more memory locations in selected list mode
	    ########################################################################
	    $lstart = $lfin = $loc;		# defaults if no address or range is specified
	    $assIn = "";
	    if ($21) {
		$listCmd = $22;
		if ($listCmd ne "<" and defined $24 and $24 ne "") {
		    warn "??? '$listCmd' command does not accept assembly code '$24'\n";
		    next;
		} else {
		    $assIn = $24;
		}
	    } else {
		$listCmd = "/";
	    }
	    if (defined $1 and $1 ne "") {
		if (defined $3) {				# start of range
		    $num = oct($3);				# octal memory reference
		} else {
		    if (defined $6) {
			if (defined($tmp = $symTable{$6})) {	# symbolic memory reference
			    $num = $tmp;
			} elsif ($6 =~ m/^([snuca])$/) {
			    warn "??? command '$1' can only be called at a break or watch point\n";
			    next;				# s n u c a in symbol table have precedence
			} else {
			    warn "??? symbolic reference '$6' has not been defined\n";
			    next;
			}
		    } elsif (defined $7) {
			$num = $loc;				# "." relative memory reference
		    }
		    if (defined $8) {
			if ($9 eq "-") {
			    $num -= $10;			# negative offset
			} elsif ($9 eq "+") {
			    $num += $10;			# positive offset
			}
		    }
		}
		$lstart = $lfin = $num;
		if (defined $11) {
		    if (defined $13) {				# optional end of range
			$num = oct($13);			# octal memory reference
		    } else {
			if (defined $16) {
			    if (defined($tmp = $symTable{$16})) {	# symbolic memory reference
				$num = $tmp;
			    } else {
				warn "??? symbolic reference '$16' has not been defined\n";
				next;
			    }
			} elsif (defined $17) {
			    $num = $loc;			# "." relative memory reference
			}
			if (defined $18) {
			    if ($19 eq "-") {
				$num -= $20;			# negative offset
			    } elsif ($19 eq "+") {
				$num += $20;			# positive offset
			    }
			}
		    }
		    $lfin = $num;
		}
	    } elsif ($listCmd eq "=" or $listCmd eq "#") {
		$lstart = 0;			# full range for listing break points
		$lfin   = 0777;
	    }
	    if ($lstart > $lfin) {
		warn"??? listing range must be rising\n";
		next;				# $loc unchanged
	    }
	    if ($lfin > 0777) {
		warn"??? memory limit is octal 777\n";
		next;				# $loc unchanged
	    }
	    if ($listCmd eq "<") {
		if ($23) {
		    $assIn = "$23$assIn";		# no list mode after < - fixes BLK and DEC
		}
		if ($assIn =~ m/^\s*([A-Za-z]\w*\s*:\s*)?[A-Z][A-Z][A-Z]/) {
		    $listMode = "c";			# code
		    $listOfs = 1;
		} elsif ($assIn =~ m/^\s*([A-Za-z]\w*\s*:\s*)?([+-]\s*)?\d/) {
		    $tmp = $2;				# + or - sign
		    if ($assIn =~ m/[lL]\s*([;#].*)?$/) {
			$listMode = $tmp ? "D" : "U";	# long number
			$listOfs = 2;
		    } else {
			$listMode = $tmp ? "d" : "u";	# short number
			$listOfs = 1;
		    }
		} elsif ($assIn =~ m/^\s*([A-Za-z]\w*\s*:\s*)?".*"/) {
		    $listMode = "s";			# string
		    $listOfs = 1;
		} elsif ($assIn !~ m/^\s*([;#].*)?$/) {	# ignore comment only
		    warn "??? cannot assemble '$assIn'\n";
		    next;			# $loc unchanged
		}
		if ($listMode eq "s" or $listMode eq "S") {
		    $lfin = $lstart;		# cannot assemble more than one string
		}
	    } elsif ($23) {
		    $listMode = $23;		# change list mode for all other commands
		    $listOfs = ($listMode =~ m/[DUOXB]/) ? 2 : 1;	# and offset
	    }
	    $stFlag = 1;
	    for ($l = $lstart; $l <= $lfin; $l += $listOfs) {
		########################################################################
		#  select command
		########################################################################
		if ($listCmd eq "*") {
		    $breaks[$l] = 1;		# set a break or watch point and list
		} elsif ($listCmd eq "#") {
		    if ($breaks[$l] == 1) {
			$breaks[$l] = 0;	# clear a break or watch point and list
		    } else {
			next;			# skip unless break or watch point was set
		    }
		} elsif ($listCmd eq "=") {
		    next if $breaks[$l] != 1;	# list break or watch points
		}
		$brkStar = $breaks[$l] ? "  *" : "";
		$label = defined($sym = $symbols{$l}) ? sprintf("%s:", $sym) : "";
		$tmp = $mem[$l];
		printf "	%03o%s	%05o	%s	", $l, $brkStar, $tmp, $label;
		$tmp += ($mem[$l+1] << 15) if $listOfs == 2;
		########################################################################
		#  select list mode
		########################################################################
		if ($listMode eq 'c') {		# list as balad code
		    my ($opc, $ind, $m, $mref);
		    if ($tmp == 0) {		# 0 instead of JMP ACC or HLT
			printf "0\n";
		    } else {
			$opc   = $opNames[($tmp & 076000) >> 10];
			$ind   = $tmp & 01000 ? "@" : "";
			$m  = $tmp & 0777;
			unless (defined($mref = $symbols{$m})) {
			    $mref = sprintf "%o", $m;
			}
			printf "%s %s%s\n", $opc, $ind, $mref;
		    }
		} elsif ($listMode eq 'd') {
		    $tmp |= -040000 if $tmp & -040000;	# extend sign
		    printf "%6d\n", $tmp;	# list as short signed decimal
		} elsif ($listMode eq 'u') {
		    printf "%6u\n", $tmp;	# list as short unsigned decimal
		} elsif ($listMode eq 'o') {
		    printf "%#6o\n", $tmp;	# list as short unsigned octal
		} elsif ($listMode eq 'x') {
		    printf "%#06x\n", $tmp;	# list as short unsigned hexadecimal
		} elsif ($listMode eq 'b') {
		    printf "%015b\n", $tmp;	# list as short unsigned binary
		} elsif ($listMode eq 'D') {
		    $tmp |= -04000000000 if $tmp & -04000000000;	# extend sign
		    printf "%10ld\n", $tmp;	# list as long signed decimal
		} elsif ($listMode eq 'U') {
		    printf "%9lu\n", $tmp;	# list as long unsigned decimal
		} elsif ($listMode eq 'O') {
		    printf "%#11lo\n", $tmp;	# list as long unsigned octal
		} elsif ($listMode eq 'X') {
		    printf "%#010lx\n", $tmp;	# list as long unsigned hexadecimal
		} elsif ($listMode eq 'B') {
		    printf "%030lb\n", $tmp;	# list as long unsigned binary
		} elsif ($listMode eq "s" or $listMode eq "S") {
		    my ($byte0, $byte1, $ch, $st);	# list as text string
		    $byte0 = $tmp & 0177;
		    $byte1 = ($tmp & 077400) >> 8;
		    if ($listMode eq "s") {
			$ch = chr $byte0;
			printf "%s ", defined($st = $cntrl_slash{$ch}) ? $st : $ch;
			$ch = chr $byte1;
			printf "%s", defined($st = $cntrl_slash{$ch}) ? $st : $ch;
		    }
		    if ($stFlag) {
			my $string = convString($l, 1);	# global $cmr returns address of next word
			if ($cmr > $lfin) {
			    $lfin = $cmr;		# extend listing to end of current string
			}
			if ($listMode eq "S") {
			    print "\"$string\"";
			    $l = $cmr;			# skip octal listing to end of string
			} else {
			    print "	\"$string\"";
			    $stFlag = 0;
			}
		    }
		    print "\n";
		    if ($byte0 == 0 or $byte1 == 0) {
			$stFlag = 1;		# end of current string found - start another
		    }
		}
		########################################################################
		#  end of list modes - default is simple list like /
		#  list hi order byte of a double precision number
		########################################################################
		printf("	%03o	%05o\n", $l+1, $mem[$l+1]) if $listOfs == 2;
		if ($listCmd eq "<" and $stFlag) {
		    ########################################################################
		    #  Assemble one code statement, one single or double precision number
		    #  which my be signed or unsigned decimal, octal, hexadcimal or binary,
		    #  or one string, which may write a number of words. The format and
		    #  restrictions are the same for BALAD source files, interactive
		    #  entry or this single line debug entry. They all call the same assembler.
		    #  The only difference is, that locations are defined by the debug address
		    #  before the < command like all other debug commands and not by LOC
		    #  or BLK statements.
		    #
		    #  This input to modify words in memory is for the purpose of debugging
		    #  and will mainly involve changing data. If just a single instruction
		    #  has to be changed - like changing the sense of a conditional JMP that
		    #  should be OK. If more code is to be changed that is probably better
		    #  done in interactive entry mode or if instructions have to be inserted,
		    #  editing the source file and calling BALAD with the modified source.
		    ########################################################################
		    if ($assIn =~ m/^\s*(LOC|BLK)/) {
			warn "??? LOC or BLK have no effect in debug single line assembly\n";
			next Input;
		    }
		    ## assemble a line out of debug ########################################
		    if (assembleLine(0, $assIn, $listMode eq "s" || $listMode eq "S" ? $lstart : $l) or
			$assIn =~ m/^\s*([;#].*)?$/) {
			next Input;			# $loc unchanged
		    }
		    $l = $loc - $listOfs;		# take $loc from assembly
		    $lfin = $l if $listMode eq "s"	# $lfin was from old string, which may be longer
			       or $listMode eq "S";	# which led to an infinite loop
		}
	    }
	    $loc = $l;
	} elsif (m/^\s*-(l?)([doxb]?)$/) {
	    ########################################################################
	    #  change trace modes
	    #    -	no tracing
	    #    -l	only list code
	    #    -lo	plus trace C, ACC, MR as octal
	    #    -o	plus trace C, ACC, MR as octal only at break points
	    #    Similarly for -ld -d -lx -x -lb -b
	    ########################################################################
	    $opt_l = $1;
	    $opt_o = $opt_d = $opt_x = $opt_b = "";
	    if ($2 eq 'o') {
		$opt_o = $2;
		$traceFormat = "%sC %d ACC %05o [%03o] %05o";
	    } elsif ($2 eq 'd') {
		$opt_d = $2;
		$traceFormat = "%sC %d ACC %5d [%03o] %5d";
	    } elsif ($2 eq 'x') {
		$opt_x = $2;
		$traceFormat = "%sC %d ACC %04x [%03o] %04x";
	    } elsif ($2 eq 'b') {
		$opt_b = $2;
		$traceFormat = "%sC %d ACC %015b [%03o] %015b";
	    }
	    $optlx =  $opt_l && ($opt_o || $opt_d || $opt_x || $opt_b);
	    $optnx = !$opt_l && ($opt_o || $opt_d || $opt_x || $opt_b);
	} else {
	    warn "???\n";
	}
    }
    if (not defined $_) { print "\n"; $abort = 1 if $mode; }	# ctrl-D
  stopDebug:
    $running = 1 if $running;
} # debug

########################################################################
#
#   Run BALAD code
#
########################################################################

sub run {
    my ($t0, $t1, $sec, $usec);
    my ($instr, $op, $num, $next, $jmsFlag, $n, $mv, $trace);
    if ($eF) {
	warn "*** ERROR: cannot run because of previous $eF assembly errors\n";
	exit;
    }
    $mem[0] = $mem[0777] = $jtA = $jtC = $jmsCall = $break = $next = $abort = 0;	# clear ACC, C and jump testers
    @jmsStack = ();
    $running = 1;
    printf ("	%3o run *********\n", $pc) if $opt_l;
    if ($opt_m) {
	$t0 = [gettimeofday];
    }
    ########################################################################
    #   Start execution with instruction at $pc
    ########################################################################
    while (($instr = $num = $mem[$pc]) != 0) {		# fetch instruction (0 is HLT)
	$op = ($instr & 076000) >> 10;			# op code
	$mr = $num & 0777;				# direct memory reference
	########################################################################
	#   Check for indirect memory reference
	########################################################################
	for ($n = 0; $num & 01000; $mr = $num & 0777) {
	    if ($op < 010) {
		$jmsFlag = ($jmsCall == $mr);
		$next = $pc + 1;			# a possible JMS return
	    }
	    $num = $mem[$mr];				# @ indirect memory reference
	    if ($n++ > 10) {
		$num = sprintf "%o", $mr;
		warn "*** EXEC ERROR: very long indirect loop at LOC $num\n";
		goto stopRun;
	    }
	}
	$opttx = $optlx || ($optnx && ($break || $breaks[$pc] ||		# trace at break point
		($breaks[$mr] && ($opTrace[$op]) ||				# or before watch point
		 $breaks[$pc+1] && ($ocTrace[($mem[$pc+1] & 076000) >> 10]))));	# or before conditional jmp
	if ($opt_l or $opttx) {
	    printf ("	%3o %05o %3s %s%03o", $pc, $instr, $opNames[$op], $instr & 01000 ? "@" : "", $instr & 0377);
	}
	$mv = $mem[$mr];				# value at $mr before execution for watch point check
	#### trace before execution ############################################
	if ($opttx) {
	    if ($opTrace[$op]) {			# ignore JMP and Print instructions for trace
		printf ($traceFormat, "\t", $mem[0777], $mem[0], $mr, $mv);
	    } elsif ($op == 037) {
		printf("\t\"%s\"", convString($mr, 1));# PRF trace dressed format string
	    }
	}
	########################################################################
	#   Check for breakpoint
	########################################################################
	if ($break or $breaks[$pc]) {
	    $loc = $pc;
	    print "\n" if $opt_l or $opttx;
	    debug(1, $op, $mr);
	    goto stopRun if $abort;			# may be set in debug()
	    print "\t\t\t   " if $opttx and $opTrace[$op];
	} elsif ($opt_l and not ($opttx and $opTrace[$op])) {
	    print "\n";					# terminate trace before JMP and Print instructions
	}
	########################################################################
	#   Exeute instruction
	########################################################################
	$pc++;						# next instruction (unless modified by JMP)
	$opSubs[$op]->();				# execute op code (all op's exist) with resolved $mr
	goto stopRun if $abort;				# may be set in KDN, KDD, KCH or KCS
	if ($next) {
	    if ($next != $pc) {				# is jump to next instruction ?
		if ($jmsFlag) {				# no - jump was true and jumped somewhere else
		    $break = 1;				#      return from JMS subroutine after n - next
		    $jmsCall = 0;
		}
		pop @jmsStack;				# for u - until
	    }
	    $next = 0;
	}
	#### trace after execution #############################################
	if ($opttx and $opTrace[$op]) {			# ignore JMP and Print instructions for trace
	    printf ($traceFormat, " ==> ", $mem[0777], $mem[0], $mr, $mem[$mr]);
	    print "\n";
	}
	########################################################################
	#   Check for watch point change of value at $mr
	########################################################################
	if ($breaks[$mr] and $opTrace[$op] and $mv != $mem[$mr]) {
	    $loc = $mr;
	    debug(2, $op, $mr);
	    goto stopRun if $abort;			# may be set in debug()
	}
    }
    ########################################################################
    #   Exeution finished - reached HLT instruction
    ########################################################################
    printf ("	%3o ***** HLT ***\n", $pc) if $opt_l;
  stopRun:
    $running = 0;
    if ($opt_m) {
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	printf "%3d.%03d,%03d seconds\n", $sec, int($usec/1000), $usec%1000;
    }
} # run

########################################################################
#
#   Functions to execute each op-code
#
########################################################################


sub JMP {		# 000000
    $pc = $mr;
} # JMP

sub JMS {		# 002000
    $mem[$mr] = $pc;	# save return address
    push @jmsStack, $mr;# record JMS calls on a stack
    $pc = $mr + 1;
} # JMS

sub JZR {		# 004000
    $pc = $mr if $jtA == 0;
} # JZR

sub JNR {		# 006000
    $pc = $mr if $jtA != 0;
} # JNR


sub JZC {		# 010000
    $pc = $mr if $jtC == 0;
} # JZC

sub JNC {		# 012000
    $pc = $mr if $jtC != 0;
} # JNC

sub JEZ {		# 014000
    $pc = $mr if $jtA == 0 or $jtC == 0;
} # JEZ

sub JBN {		# 016000
    $pc = $mr if $jtA != 0 and $jtC != 0;
} # JBN


sub AND {		# 020000
    $jtA = $mem[0] &= $mem[$mr];	# and accumulator (carry not affected)
} # AND

sub ADD {		# 022000
    $jtA = $mem[0] + $mem[0777] + $mem[$mr];	# add to accumulator and carry
    if ($jtA & ~077777) {		# overflow ?
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] = 1;		# set carry
    } else {
	$jtC = $mem[0777] = 0;		# clear carry
    }
    $mem[0] = $jtA;
} # ADD

sub SUB {		# 024000
    $jtA = $mem[0] + ($mem[0777] ^ 1) + ($mem[$mr] ^ 077777);	# add twos complement to accumulator and carry
    if ($jtA & ~077777) {		# overflow ?
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] = 0;		# clear carry
    } else {
	$jtC = $mem[0777] = 1;		# set carry
    }
    $mem[0] = $jtA;
} # SUB

sub CMP {		# 026000
    $jtA = $mem[0] + 1 + ($mem[$mr] ^ 077777);	# add twos complement to accumulator (carry cleared)
    if ($jtA & ~077777) {		# overflow ?
	$jtA &= 077777;			# yes - mask accumulator in jump tester only
	$jtC = 1;			# set carry in jump tester only
    } else {
	$jtC = 0;
    }
} # CMP


sub LDA {		# 030000
    $jtA = $mem[0] = $mem[$mr];		# load accumulator
} # LDA

sub STA {		# 032000
    $jtA = $mem[$mr] = $mem[0];		# store accumulator
    $jtC = $mem[0777] &= 1 if $mr == 0777; # may set or reset carry
} # STA

sub CLR {		# 034000
    $jtA = $mem[$mr] = 0;		# clear memory location
    $jtC = 0 if $mr == 0777;		# may also clear carry
} # CLR

sub TST {		# 036000
    $jtA = $mem[$mr];
    $jtC = $mem[0777] & 1 if $mr == 0777; # may test carry
} # TST


sub COM {		# 040000
    $jtA = $mem[$mr] = $mem[$mr] ^ 077777;	# bitwise complement memory location
    $jtC = $mem[0777] &= 1 if $mr == 0777;	# may also complement carry
} # COM

sub NEG {		# 042000
    $jtA = ($mem[0777] ^ 1) + ($mem[$mr] ^ 077777); # twos complement memory location
    if ($jtA & ~077777) {		# overflow ?
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] ^= 000001;	# complement carry
    }
    $mem[$mr] = $jtA;
} # NEG

sub INC {		# 044000
    $jtA = $mem[$mr] + 1;
    if ($jtA & ~077777) {
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] ^= 000001;	# complement carry
    }
    $mem[$mr] = $jtA;
} # INC

sub DEC {		# 046000
    $jtA = $mem[$mr] - 1;
    if ($jtA & ~077777) {
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] ^= 000001;	# complement carry
    }
    $mem[$mr] = $jtA;
} # DEC


sub ROL {		# 050000	# shift operators should not operate on carry
    $jtA = ($mem[$mr] << 1) + $mem[0777];
    $jtC = $mem[0777] = $jtA >> 15;
    $mem[$mr] = $jtA &= 077777;
} # ROL

sub ROR {		# 052000
    $jtC = $mem[$mr] & 000001;
    $jtA = ($mem[$mr] >> 1) + ($mem[0777] << 14);
    $mem[$mr] = $jtA;
    $mem[0777] = $jtC;
} # ROR

sub ASR {		# 054000
    $jtC = $mem[$mr] & 000001;
    $jtA = $mem[$mr];
    $jtA += (($jtA & 040000) << 1);
    $mem[$mr] = $jtA >>= 1;
    $mem[0777] = $jtC;
} # ASR

sub SWP {		# 056000
    $jtA = (($tmp = $mem[$mr]) & 0177) << 8;
    $mem[$mr] = $jtA += $tmp >> 8;
} # SWP


sub KDN {		# 060000
    print "\n" if $opttx;
    my $prompt = ($tmp = $mem[0776] & 0777)
		   ? convString($tmp, 0)
		   : "Enter a short number";
  RepeatKDN:
    $_ = $term->readline("$prompt: ");
    if (not defined $_) { print "\n"; $abort = 1; return; }	# ctrl-D
    $jtA = +$_;
    $jtA = oct $jtA if $jtA =~ m/^0/;
    if ($jtA > 077777 or $jtA < ~037777) {
	warn "*** ERROR: short number must be <= 32,767 or >= -16384\n";
	$prompt = "Try again";
	goto RepeatKDN;
    }
    $mem[$mr] = $jtA & 077777;
    print "\t\t\t   " if $opttx;
} # KDN

sub KDD {		# 062000
    print "\n" if $opttx;
    my $prompt = ($tmp = $mem[0776] & 0777)
		   ? convString($tmp, 0)
		   : "Enter a long number";
  RepeatKDD:
    $_ = $term->readline("$prompt: ");
    if (not defined $_) { print "\n"; $abort = 1; return; }	# ctrl-D
    $jtA = +$_;
    $jtA = oct $jtA if $jtA =~ m/^0/;
    if ($jtA > 07777777777 or $jtA < ~03777777777) {
	warn "*** ERROR: long number must be <= 1,073,741,823 or >= -536,870,912\n";
	$prompt = "Try again";
	goto RepeatKDD;
    }
    $mem[$mr] = $jtA & 077777;		# long number
    $mem[$mr+1] = ($jtA >> 15) & 077777;
    print "\t\t\t   " if $opttx;
} # KDD

sub KCH {		# 064000
    print "\n" if $opttx;
    ReadMode('cbreak');
    my $byte = ReadKey(0);			# single character from keyboard (stdin)
    if (not defined $byte or ord($byte) == 04) { ReadMode('normal'); print "\n"; $abort = 1; return; }	# ctrl-D
    $jtA = $mem[$mr] = ord $byte;		# do not echo single character input
    ReadMode('normal');
    print "\t\t\t   " if $opttx;
} # KCH

sub KCS {		# 066000
    print "\n" if $opttx;
    my ($num, $char, $bs, $byte, $char0, $bs0, $byte0);
    my $ms = $mr;
    my $prompt = ($tmp = $mem[0776] & 0777)
		   ? convString($tmp, 0)
		   : "Enter a text string";
  RepeatKCS:
    $_ = $term->readline("$prompt: ");
    if (not defined $_) { print "\n"; $abort = 1; return; }	# ctrl-D
    $char0 = '';
    $byte0 = $bs0 = $bs = $jtA = 0;
    foreach $char (split //, $_) {
	$byte = ord($char);
	if ($bs) {
	    if ($byte == 0156) {
		$byte = 012;				# "\n"  LF
	    } elsif ($byte == 0164) {
		$byte = 011;				# "\t"  HT
	    }
	} elsif ($byte == 0134) {
	    $bs   = 0134;				# '\'
	    next;
	} elsif ($byte == 011) {
	    $char = "\\t";				# real HT display as '\t'
	}
	if ($byte0) {
	    if ($mr >= 0776) { goto KCSERR0; }
	    $num = (($byte & 0177) << 8) + ($byte0 & 0177);
	    printf("	%03o	%05o	%c%s %c%s\n", $mr, $num, $bs0, $char0, $bs, $char) if $opttx;
	    $mem[$mr++] = $num;
	    $byte0 = 0;
	    $char0 = '';
	    $bs0   = 0;
	} else {
	    $byte0 = $byte;
	    $char0 = $char;
	    $bs0   = $bs;
	}
	$bs = 0;					# all other chars following '\' unchanged
    }
    if ($mr >= 0776) { goto KCSERR0; }
    $num = ($byte0 & 0177);
    printf("	%03o	%05o	%c%s\n\t\t\t   ", $mr, $num, $bs0, $char0) if $opttx;
    $mem[$mr] = $num;					# last terminating word
    $jtA = (($tmp = $mem[$ms]) != 0 && $tmp != 060);	# "" or "0" but not "00" are false
    return;
  KCSERR0:
    warn "*** ERROR: String will overflow memory\n";
    $prompt = "Try again with a shorter string";
    $mr = $ms;
    goto RepeatKCS;
} # KCS


sub PDN {		# 070000
    $jtA = $mem[$mr];			# single precision unsigned number
    if ($jtA & 040000 & $mem[0776]) {
	$jtA |= -040000;		# extend sign for short signed number
    }
    printf "%d\n", $jtA;		# print single precision number
} # PDN

sub PDD {		# 072000
    $jtA = $mem[$mr++];
    $jtA += $mem[$mr] << 15;		# double precision unsigned number
    if ($jtA & 04000000000 & ($mem[0776] << 15)) {
	$jtA |= -04000000000;		# extend sign for long signed number
    }
    printf "%ld\n", $jtA;		# print double precision number
} # PDD

sub PCH {		# 074000
    printf "%c", $jtA = $mem[$mr];	# print single character
} # PCH

sub PRF {		# 076000
    my ($num, $sign, $format, $i);
    my @nums = ();			# print string with optional numeric printf %d formats
    $jtA = $mem[$mr];			# 0 if argument is NULL string ""
    $format = convString($mr, 0);	# raw string
    $i = 1;
    @nums = ();
    while ($format =~ m/
	    (				# $1
		%
		([# +-]?)		# $2
		(\d+)?			# $3
		(\.\d+)?		# $4
		(l?)			# $5
		([csdDuUboOxX])		# $6
	    )
	/gx) {
	$tmp = $mem[$pc++];			# fetch address of next number parameter
	while (defined($mr = $tmp & 0777) and $tmp & 01000) {
	    $tmp = $mem[$mr];		# @ indirect memory reference
	    if (($tmp & 01777) == ($mr | 01000)) {
		$num = sprintf "%o", $mr;
		warn "*** EXEC ERROR: infinite indirect loop at LOC $num\n";
		return;
	    }
	}
	if ($6 eq 'c') {
	    $num = $mem[$mr] & 0177;	# %c	single character
	} elsif ($6 eq 's') {
	    $num = convString($mr, 0);	# %s	raw string
	} else {
	    $num = $mem[$mr];		# %d %D %u %U %b %o %O %x %X or %ld etc
	    if ($5 or $6 eq 'D' or $6 eq 'U' or $6 eq 'O') {
		$num += $mem[$mr+1] << 15;	# %D %U %O or "ld" etc
		$sign = -04000000000;		# double precision number
	    } else {
		$sign = -040000;	# %d etc  single precision number
	    }
	    if (($6 eq 'd' or $6 eq 'D') and ($num & $sign)) {
		$num |= $sign;		# sign extend signed negative number
	    }
	}
	push @nums, $num;		# collect parameters for each %d etc format element
	printf("\t%03o   %03o\t\t%2d %s\t'%s'\n", $pc-1, $mr, $i, $1, $6 eq 'c' ? chr $num : $num) if $opttx;
	$i++;
    }
    printf $format, @nums;		# use perl printf for output of collected elements
    print "\n" if ($opt_l or $opttx) and $format !~ m/\n$/;
} # PRF
