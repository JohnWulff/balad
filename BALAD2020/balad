#!/usr/bin/perl -w

########################################################################
#
#	Copyright (C) 2020  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the next line.
#
#	SPDX-License-Identifier: GPL-3.0+ OR Artistic-2.0
#
#	BALAD assembler, interpreter and debugger
#
#   Balad is an assembly level programming language for an emulated
#   virtual computer with a 15 bit word length. It is combined with a
#   comprehensive debugging system which allows on line program assembly,
#   execution of programs and the insertion of breakpoints to allow
#   suspension of programs during execution.
#
#   Instructions are machine oriented, using integer and logical
#   operations only. As a concession to the beginner extra instructions
#   are provided for single character, decimal number as well as text
#   string input and output. These facilities will enable students to
#   obtain reasonable displays of their results quickly, while
#   concentrating their efforts on developing algorithms.
#
########################################################################

use strict;
use integer;
use warnings;
use Term::ReadKey;
use Term::ReadLine;
$| = 1;				# output stdout buffer for every print or printf

########################################################################
#
#	Opcodes	- Hash used during assembly
#	    $opCodes{KEY}[0]	$instr ($op = $instr >> 10)
#	    $opCodes{KEY}[1]	may operate on carry for this KEY
#
########################################################################

my %opCodes = (    # $instr  c                       $instr  c            $op
	JMP	=> [ 000000, 1, ],	ADR	=> [ 000000, 0, ],	#  0
	JMS	=> [ 002000, 1, ],	# may not JMP to carry		#  1
	JZR	=> [ 004000, 1, ],	JEQ	=> [ 004000, 1, ],	#  2
	JNR	=> [ 006000, 1, ],	JNE	=> [ 006000, 1, ],	#  3

	JZC	=> [ 010000, 1, ],	JLT	=> [ 010000, 1, ],	#  4
	JNC	=> [ 012000, 1, ],	JGE	=> [ 012000, 1, ],	#  5
	JEZ	=> [ 014000, 1, ],	JLE	=> [ 014000, 1, ],	#  6
	JBN	=> [ 016000, 1, ],	JGT	=> [ 016000, 1, ],	#  7

	AND	=> [ 020000, 0, ],	# double operands can use carry	#  8
	ADD	=> [ 022000, 0, ],					#  9
	SUB	=> [ 024000, 0, ],					# 10
	CMP	=> [ 026000, 0, ],					# 11

	LDA	=> [ 030000, 0, ],	# may load carry		# 12
	STA	=> [ 032000, 0, ],	# may operate on carry		# 13
	CLR	=> [ 034000, 0, ],	# may operate on carry		# 14
	TST	=> [ 036000, 0, ],	# may test carry		# 15

	COM	=> [ 040000, 0, ],	# may complement carry		# 16
	NEG	=> [ 042000, 1, ],	# inhibit operation on carry	# 17
	INC	=> [ 044000, 1, ],					# 18
	DEC	=> [ 046000, 1, ],					# 19

	ROL	=> [ 050000, 1, ],					# 20
	ROR	=> [ 052000, 1, ],					# 21
	ASR	=> [ 054000, 1, ],					# 22
	SWP	=> [ 056000, 1, ],					# 23

	KDN	=> [ 060000, 1, ],					# 24
	KDD	=> [ 062000, 1, ],					# 25
	KCH	=> [ 064000, 1, ],					# 26
	KCS	=> [ 066000, 1, ],					# 27

	PDN	=> [ 070000, 0, ],	TDN	=> [ 070000, 0, ],	# 28  may print carry
	PDD	=> [ 072000, 1, ],	TDD	=> [ 072000, 1, ],	# 29
	PCH	=> [ 074000, 0, ],	TCH	=> [ 074000, 0, ],	# 30  may print carry
	PRF	=> [ 076000, 1, ],	TCS	=> [ 076000, 1, ],	# 31
);

########################################################################
#
#	Three arrays accessed by op code 0 - 31 (0 - 037)
#
#	    $opNames[op]	op code NAME for disassembly
#	    $opSubs[op]		op code subroutine reference
#	    $opTrace[op]	trace C ACC and [mem] for this op code
#	    $ocTrace[op]	trace C ACC and [mem] for instr before conditional jmp
#
#	These are implemented as four separate arrays for speed, since
#	@opSubs, @opTrace and @ocTrace are accessed for each instruction execution
#
########################################################################

my @opNames = ( # $instr $op
	"JMP",	# 000000  0
	"JMS",	# 002000  1
	"JZR",	# 004000  2
	"JNR",	# 006000  3

	"JZC",	# 010000  4
	"JNC",	# 012000  5
	"JEZ",	# 014000  6
	"JBN",	# 016000  7

	"AND",	# 020000  8
	"ADD",	# 022000  9
	"SUB",	# 024000 10
	"CMP",	# 026000 11

	"LDA",	# 030000 12
	"STA",	# 032000 13
	"CLR",	# 034000 14
	"TST",	# 036000 15

	"COM",	# 040000 16
	"NEG",	# 042000 17
	"INC",	# 044000 18
	"DEC",	# 046000 19

	"ROL",	# 050000 20
	"ROR",	# 052000 21
	"ASR",	# 054000 22
	"SWP",	# 056000 23

	"KDN",	# 060000 24
	"KDD",	# 062000 25
	"KCH",	# 064000 26
	"KCS",	# 066000 27

	"PDN",	# 070000 28
	"PDD",	# 072000 29
	"PCH",	# 074000 30
	"PRF",	# 076000 31
);

my @opSubs = (  # $instr $op
	\&JMP,	# 000000  0
	\&JMS,	# 002000  1
	\&JZR,	# 004000  2
	\&JNR,	# 006000  3

	\&JZC,	# 010000  4
	\&JNC,	# 012000  5
	\&JEZ,	# 014000  6
	\&JBN,	# 016000  7

	\&AND,	# 020000  8
	\&ADD,	# 022000  9
	\&SUB,	# 024000 10
	\&CMP,	# 026000 11

	\&LDA,	# 030000 12
	\&STA,	# 032000 13
	\&CLR,	# 034000 14
	\&TST,	# 036000 15

	\&COM,	# 040000 16
	\&NEG,	# 042000 17
	\&INC,	# 044000 18
	\&DEC,	# 046000 19

	\&ROL,	# 050000 20
	\&ROR,	# 052000 21
	\&ASR,	# 054000 22
	\&SWP,	# 056000 23

	\&KDN,	# 060000 24
	\&KDD,	# 062000 25
	\&KCH,	# 064000 26
	\&KCS,	# 066000 27

	\&PDN,	# 070000 28
	\&PDD,	# 072000 29
	\&PCH,	# 074000 30
	\&PRF,	# 076000 31
);

my @opTrace = ( # $instr $op
	0,	# 000000  0	JMP	no trace
	1,	# 002000  1	JMS	trace before and after execution
	0,	# 004000  2	JZR
	0,	# 006000  3	JNR

	0,	# 010000  4	JZC
	0,	# 012000  5	JNC
	0,	# 014000  6	JEZ
	0,	# 016000  7	JBN

	1,	# 020000  8	AND
	1,	# 022000  9	ADD
	1,	# 024000 10	SUB
	1,	# 026000 11	CMP

	1,	# 030000 12	LDA
	1,	# 032000 13	STA
	1,	# 034000 14	CLR
	1,	# 036000 15	TST

	1,	# 040000 16	COM
	1,	# 042000 17	NEG
	1,	# 044000 18	INC
	1,	# 046000 19	DEC

	1,	# 050000 20	ROL
	1,	# 052000 21	ROR
	1,	# 054000 22	ASR
	1,	# 056000 23	SWP

	1,	# 060000 24	KDN
	1,	# 062000 25	KDD
	1,	# 064000 26	KCH
	1,	# 066000 27	KCS

	0,	# 070000 28	PDN
	0,	# 072000 29	PDD
	0,	# 074000 30	PCH
	0,	# 076000 31	PRF
);

my @ocTrace = ( # $instr $op
	0,	# 000000  0	JMP
	0,	# 002000  1	JMS
	1,	# 004000  2	JZR	trace instruction before conditional jmp
	1,	# 006000  3	JNR

	1,	# 010000  4	JZC
	1,	# 012000  5	JNC
	1,	# 014000  6	JEZ
	1,	# 016000  7	JBN

	0,	# 020000  8	AND
	0,	# 022000  9	ADD
	0,	# 024000 10	SUB
	0,	# 026000 11	CMP

	0,	# 030000 12	LDA
	0,	# 032000 13	STA
	0,	# 034000 14	CLR
	0,	# 036000 15	TST

	0,	# 040000 16	COM
	0,	# 042000 17	NEG
	0,	# 044000 18	INC
	0,	# 046000 19	DEC

	0,	# 050000 20	ROL
	0,	# 052000 21	ROR
	0,	# 054000 22	ASR
	0,	# 056000 23	SWP

	0,	# 060000 24	KDN
	0,	# 062000 25	KDD
	0,	# 064000 26	KCH
	0,	# 066000 27	KCS

	1,	# 070000 28	PDN	trace instruction before print instructions
	1,	# 072000 29	PDD
	1,	# 074000 30	PCH
	0,	# 076000 31	PRF	leave out print string
);

my @mem		= (0) x 01001;	# BALAD memory 0 - 777 initialised to 0 (HLT)
my @breaks	= (0) x 01001;	# BALAD breaks 0 - 777 initialised to 0
my @memSrc	= () x 01001;	# attach source lines to memory locations
my @lines	= ();		# temporory array for source lines
my @groups	= ();		# array to record source consecutive groups of defined locations
my @pair	= ();		# array to record start and end of a consecutive group
my $break	= 0;		# break at next instuction step when set
my $running	= 0;		# 0 not running 1 running not at break point 2 running at break
my $jmsCall	= 0;		# address of current JMS subroutine
my @jmsStack	= ();		# stack of JMS calls
my %symTable	= ( ACC => 0, C => 0777 );	# define names of accumulator and carry
my %symbols	= ( 0 => "ACC", 511 => "C" );	# define inverse symbols
my %cntrl_slash	= (		# forward control character translation
	"\a"	=> "\\a",	# BEL	alarm
	"\b"	=> "\\b",	# BS	back space
	"\t"	=> "\\t",	# HT	horizontal tab
	"\n"	=> "\\n",	# LF	new line
	"\f"	=> "\\f",	# FF	form feed
	"\r"	=> "\\r",	# CR	carriage return
	"\e"	=> "\\e",	# ESC
);
my %ascii_cntrl	= (		# inverse translation ascii following '\'
	"a"	=> "\a",	# BEL	alarm
	"b"	=> "\b",	# BS	back space
	"t"	=> "\t",	# HT	horizontal tab
	"n"	=> "\n",	# LF	new line
	"f"	=> "\f",	# FF	form feed
	"r"	=> "\r",	# CR	carriage return
	"e"	=> "\e",	# ESC
);
my @debPrompts	= ( ">>", "B>", "W>" );			# debug() entry prompts

my $named = $0;
$named =~ s#.*[/\\]##;		# delete directory names in path
my @argv1 = ();
my ($argv, $loc, $state, $pc, $mr, $tmp, $jR, $jC, $listMode, $lM, $listOfs, $lO, $abort, $cmr, $listArgv);
my @errorMsgs = ();

format STDERR =
Usage:  @<<<<[ -lt[doxb]cmh
        $named
             [ -L[ <list_file>]][ -O <out_file>]
             [ -B[ <batch_file>]][ <file> ...]
        -l      list code output during assembly
        -t      trace code during execution
          -d    additionally  trace C, ACC and MR in decimal
          -o    alternatively trace C, ACC and MR in octal
          -x    alternatively trace C, ACC and MR in hexadecimal
          -b    alternatively trace C, ACC and MR in binary
             In each case trace values before and after execution.
             Without -t trace only at break or watch points.
             Can also be applied at run time as debug commands.
        -c      assembly only - no execution
        -L <list_file> during assembly (default <source_file.bll>)
        -O <out_file>  during code entry (no default)
        -m      show execution time in microsecond resolution
        -h <file>   output the application help text if any
        -h      output the BALAD and its debugger help text
        <file>  one or more balad source files (ext .bl).
$Id: balad 1.7 $

        After successful assembly the program starting at 'main'
        (if defined) is run - else enter the Debugger (prompt >>).
        If there is no <source> file enter code interactively.

.

format_lines_per_page STDOUT 72;	# increase from default 60
format STDOUT =
 Debugger
    Location addresses <n> or <m> may be an octal number
    or  a defined address label [+/- a decimal offset]
    or  . [+/- a decimal offset], where . is the current location
    or  @<n> where the adress is the contents of location <n>
        "@<"

 >> enter a debug command when program is not running
        The run or enter command can only be called at >>
    r      run code from address 'main' if defined - else 0100
    <n>r   run code from address <n>
    e      enter new or revised code or data interactively
           terminate entry with key q or ctrl D (EOF)

 B> enter a debug command at a break point
 W> enter a debug command at a watch point
        The following commands can only be called at a break
        or watch point of an interrupted running program
    s      STEP to next instruction, entering into JMS subroutines
    n      execute NEXT instruction skipping over JMS subroutines
    u      continue execution UNTIL leaving current subroutine
    c      CONTINUE execution until next break or watch point
    a      abort the current program - allow new run or enter

        All other commands can be called in all modes.
    O         output the source text to STDOUT
    O <file>  output the source text to <file>
    L         output the listing text to STDOUT
    L <file>  output the listing text to <file>
    S         output the Symbol Table
    H         output the application Help text if any
    h         output the BALAD debugger help text
    q         QUIT balad

    *         set a BREAK or watch point at current location
    <n>*      set a BREAK or watch point at location <n>
    <n>,<m>*  set BREAK or watch points at locations <n> to <m>
    #         CLEAR all break or watch points
    .#        CLEAR a break or watch point at current location
    <n>#      CLEAR a break or watch point at location <n>
    <n>,<m>#  CLEAR break or watch points at locations <n> to <m>
    =         list all break or watch points
    <n>,<m>=  list break or watch points in range <n> to <m>
    < <code>  assemble <code> or <data> at current location
    <n> < <code>  assemble <code> or <data> at location <n>
                  this allows the modification of single locations

        List commands show an octal memory address and the contents
    /c        list current location as code
    <n>/c     list location <n> as code
    <n>,<m>/c list locations <n> to <m> as code

        Similarly for different list modes
    /d    short signed decimal       /D    long signed decimal
    /u    short unsigned decimal     /U    long unsigned decimal
    /o    short unsigned octal       /O    long unsigned octal
    /x    short unsigned hexadecimal /X    long unsigned hexadecimal
    /b    short unsigned binary      /B    long unsigned binary
    /s    text string up to next NULL
        these apply to all other commands starting at * (set a BREAK)
    / or enter    list location(s) in current list mode

    -t    trace code during execution.
      -d  additionally  trace C, ACC and MR in decimal
      -o  alternatively trace C, ACC and MR in octal
      -x  alternatively trace C, ACC and MR in hexadecimal
      -b  alternatively trace C, ACC and MR in binary
          In each case trace values before and after execution.
          Without -t trace only at break or watch points.
    -     stop tracing code and data during execution.
.

use vars qw($opt_l $opt_t $opt_o $opt_d $opt_x $opt_b $opt_c $opt_L $opt_O $opt_B $opt_m $opt_h);
use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    '<>'  => sub { push(@argv1, @_); },	# Transfer file argument to @argv1
    'l'   => \$opt_l,
    't'   => \$opt_t,
    'o'   => \$opt_o,
    'd'   => \$opt_d,
    'x'   => \$opt_x,
    'b'   => \$opt_b,
    'c'   => \$opt_c,
    'L:s' => \$opt_L,
    'O=s' => \$opt_O,
    'B:s' => \$opt_B,
    'm'   => \$opt_m,
    'h'   => \$opt_h,
);
push(@argv1, @ARGV) if @ARGV;				# in case -- is used in command line

if ($opt_h) {
    if (@argv1) {
	appHelp();					# output application help text
    } else {
	write STDERR; write STDOUT;			# -h, ouput Usage only
    }
    exit 0;
}

my $opttdoxb = $opt_t || $opt_d || $opt_o || $opt_x || $opt_b;
my $optlx =  $opt_t && ($opt_o || $opt_d || $opt_x || $opt_b);
my $optnx = !$opt_t && ($opt_o || $opt_d || $opt_x || $opt_b);
my ($opttx, $traceFormat);
if ($opt_o) {
    $traceFormat = "%sC %d ACC %05o [%03o] %05o";	# octal has precedence
} elsif ($opt_d) {
    $traceFormat = "%sC %d ACC %5d [%03o] %5d";
} elsif ($opt_x) {
    $traceFormat = "%sC %d ACC x%04x [%03o] x%04x";
} elsif ($opt_b) {
    $traceFormat = "%sC %d ACC %015b [%03o] %015b";
}

if ($opt_m) {
    use Time::HiRes qw(gettimeofday);
}

my $eF = 0;
my $list = 0;
my $term = Term::ReadLine->new('balad');
$SIG{QUIT} = \&interrupt;	# signal 3	(ctrl-\ interrupt from keyboard)
$SIG{PIPE} = \&interrupt;	# signal 13

# Pass 1 - process labels only
my $filesAssd	= 0;		# number of BALAD source files assembled
$pair[0] = $loc = 0100;		# first default location
for (my $i = 0; $i <= $#argv1; $i++) {
    $argv = $argv1[$i];
    open IN, $argv or
	die "can't open input file $argv";
    if (defined $opt_L) {
	if ($opt_L eq "") {
	    if ($argv =~ m/^(\w+([\/\\]\w+)*)(\.\w+)?$/) {
		$opt_L = "$1.bll";		# set list file name from the first source file trunk
	    } else {
		$opt_L = "$argv.bll";		# set list file name from the first source file name
	    }
	}
	if ($opt_L eq $argv) {
	    warn "<list_file> should not overwrite source file '$argv'\n - define new -L <list_file> in debug\n";
	    $opt_L = '0';
	}
    }
    if (defined $opt_O and $opt_O eq $argv) {
	warn "<out_file> should not overwrite source file '$argv'\n - define new -O <out_file> in debug\n";
	$opt_O = '0';
    }
    $eF += assembleFile(1);	# Pass 1
    $filesAssd++;
    close(IN);
}

# Pass 2 - full assembly
$loc = 0100;					# first default location
for (my $i = 0; $i <= $#argv1; $i++) {
    $argv = $argv1[$i];
    open IN, $argv or
	die "can't open input file $argv";	# unlikely - will have died in pass 1
    if ($filesAssd >= 2) {
	print "$argv\n";
	if ($list > 2) {
	    print LIST "$argv\n";
	} else {
	    $listArgv = $argv;
	}
    }
    $eF += assembleFile(2);	# Pass 2
    close(IN);
}
if ($list) {
    $listArgv = "";
    close(LIST);
    $list = 0;
}

unless ($eF or $opt_c and $filesAssd) {
    ########################################################################
    #   Enter run and debugging commands
    ########################################################################
    $opt_L = "-" unless $opt_L;	# listing to STDOUT
    $opt_O = "-" unless $opt_O;	# file output to STDOUT
    $loc = 0100;		# first default location
    $listMode = $lM = 'c';	# list code initially
    $listOfs  = $lO = 1;	# list offset is 1
    debug(0);
}
exit($eF);			# quit BALAD reporting errors
### End of Perl main ########################################################

########################################################################
#
#  Catch and report stray signals
#
########################################################################

sub interrupt {
    my $signame = shift;
    if ($signame =~ /^QUIT/) {
	$break = 1 if $running == 1;
    } else {
	die "$named: Caught SIG$signame: $!";
    }
} # catch_zap

########################################################################
#
#  Convert a BALAD string to a PERL string
#	$string = convString($memr, $vis)
#	parameter1	memref of BALAD string
#	parameter2	false: raw; true: vis \t \n etc (default raw)
#	return		perl string
#	$cmr - global	memref of BALAD word after string
#
########################################################################

sub convString {
    my ($memr, $vis) = @_;
    my ($mval, $byte, $ch, $st);
    my @nums = ();
    for ($cmr = $memr; ; $cmr++) {
	$mval = $mem[$cmr];
	last if ($byte = $mval & 0177) == 0;
	$ch = chr $byte;
	push @nums, $vis && defined($st = $cntrl_slash{$ch}) ? $st : $ch;
	last if ($byte = ($mval & 077400) >> 8) == 0;
	$ch = chr $byte;
	push @nums, $vis && defined($st = $cntrl_slash{$ch}) ? $st : $ch;
    }
    $st = join "", @nums;	# build string
    return $st;			# global $cmr returns memory ref of word after string
} # convString

########################################################################
#
#  Output Symbol Table
#
########################################################################

sub outSymTab {
	my ($key, $val, $v);
	foreach $key (sort keys %symTable) {
	    $val = ($v = $symTable{$key}) & 0777;
	    if ($v & 01000) {
		printf "%-11s at", $key;			# undefined symbol
		do {
		    printf " %03o", $val;			# locations
		    $val = $mem[$val] & 0777;
		} while ($val);
		printf " *** not defined\n";
	    } else {
		printf "%-11s %03o\n", $key, $val & 0777;	# defined symbol
	    }
	}
} # outSymTab

########################################################################
#
#  Output application help
#
########################################################################

sub appHelp {
    for (my $i = 0; $i <= $#argv1; $i++) {
	my $argv = $argv1[$i];
	open IN, $argv or
	    die "can't open input file $argv";
	my $hf = 0;
	while (<IN>) {					# input from file or stdin until EOF
	    unless ($hf) {
		$hf = 1 if m/^\s*q$/ or m/^\s*__END__/;	# end of code
		next;					# ignore code for help output
	    }
	    print;					# display help text if any
	}
	unless ($hf) {
	    print "$argv does not have any help text\n";
	}
    }
}

########################################################################
#
#  Output source or listing
#	parameter1	lst:    0 output source; 1 output listing
#	parameter2	fileNm: file name or "-" for STDOUT
#
########################################################################

sub outText {
    my ($lst, $fileNm) = @_;
    $listArgv = "";
    ListOpen($fileNm) unless $list;
    my ($p, $l, $arRef, $arLast, $i, $str, $end, $lj);
    for ($p = 0; $p <= $#groups; $p++) {
	for ($l = $groups[$p][0]; $l < $groups[$p][1]; $l++) {
	    if (defined($arRef = $memSrc[$l])) {
		$arLast = $#$arRef;
		for ($i = 0; $i <= $arLast; $i++) {
		    $_ = $arRef->[$i];
		    if ($lst) {
			if ($i < $arLast or $l >= 01000) {
			    printf LIST "\t\t%s\n", $_;				# comment line only
			} else {
			    printf LIST "  %03o\t%05o\t%s\n", $l, $mem[$l], $_;	# statement listing
			    if (m/^\s*([A-Za-z]\w*\s*:\s*)?"(.*)"(\s*[;#].*)?$/) {
				$str = $2;			# string
				$str =~ s/\\(.)/$1/g;		# count backslasched characters as 1
				$end = $l + (length($str) / 2);	# word end of string
				goto ExtendList;
			    } elsif (m/^\s*([A-Za-z]\w*\s*:\s*)?BLK\s*([1-9]\d*)(\s*[;#].*)?$/) {
				$end = $l + $2 - 1;		# word end of BLK
				goto ExtendList;
			    } elsif (m/^\s*([A-Za-z]\w*\s*:\s*)?[1-9]\d*[lL](\s*[;#].*)?$/ or	# unsigned DP decimal
				     m/^\s*([A-Za-z]\w*\s*:\s*)?0[0-7]*[lL](\s*[;#].*)?$/ or	# DP octal number
				     m/^\s*([A-Za-z]\w*\s*:\s*)?0[xX][0-9a-fA-F]+[lL](\s*[;#].*)?$/ or # DP hexadecimal number
				     m/^\s*([A-Za-z]\w*\s*:\s*)?0[bB][01]+[lL](\s*[;#].*)?$/ or	# DP binary number
				     m/^\s*([A-Za-z]\w*\s*:\s*)?[-+]\s*\d+[lL](\s*[;#].*)?$/) {	# signed DP decimal
				$end = $l + 1;			# 2nd word of DP number
			      ExtendList:
				for ($lj = $l + 1; $lj <= $end; $lj++) {
				    printf LIST "  %03o\t%05o\n", $lj, $mem[$lj];	# string or BLK data
				}
			    }
			}
		    } else {
			printf LIST "%s\n", $_;	# source line only
		    }
		}
	    }
	}
    }
    if ($list) {
	close(LIST);
	$list = 0;
    }
} # outText

########################################################################
#
#  Open LIST file on first output
#	parameter1	fileNm: file name or "-" for STDOUT
#
########################################################################

sub ListOpen {
    my ($fileNm) = @_;
    if ($fileNm and not fileno LIST) {
	open LIST, ">$fileNm" or
	    die "can't open file '$fileNm' for writing";
	$list = fileno LIST;
	if ($listArgv) {
	    print LIST "$listArgv\n";
	    $listArgv = "";
	}
    } else {
	$list = 0;
    }
} # ListOpen

########################################################################
#
#  List assembly output
#    output List line to STDOUT
#    output List line to LIST if $list > 2 ($opt_L corrrect)
#
########################################################################

sub List {
    my ($msg) = @_;
    ListOpen($opt_L) unless $list;
    print "$msg\n";
    print LIST "$msg\n" if $list > 2;
    while (($msg = pop(@errorMsgs))) {
	warn $msg;
	print LIST $msg if $list > 2;
    }
} # List

########################################################################
#
#  Warn about assmbly errors
#    output ERROR message to STDERR using warn()
#    output ERROR message to LIST if $list > 2 ($opt_L corrrect)
#	parameter1	ERROR message
#	parameter2	false: delay if code line;
#			1:     immediate output with file ref and line No
#			2:     immediate output without file ref
#
########################################################################

sub Error {
    my ($msg, $imm) = @_;
    ListOpen($opt_L) unless $list;
    $tmp = sprintf "*** ERROR: %s at %s line %d\n", $msg, $argv, $.;
    if ($_ and not $imm) {
	if ($opt_l) {
	    push(@errorMsgs, $tmp);
	} else {
	    warn "\t\t\t$_\n$tmp";
	    print LIST "$.\t$_\n$tmp" if $list > 2;
	}
    } elsif ($imm == 1) {
	warn $tmp;
	print LIST $tmp if $list > 2;
    } else {
	warn "*** ERROR: $msg\n";		# $imm >= 2
	print LIST "*** ERROR: $msg\n" if $list > 2;
    }
} # Error

########################################################################
#
#	Typical BALAD assembler language code
#
#	When 'balad' is first started, all locations 0 to 777 are set to 00000
#	which means they are all HLT instructions.
#	If pre-tested routines are to be entered from files, they should
#	be listed as arguments to the 'balad' command:
#	    balad multply.bl divide.bl double.bl
#	After the last file interactive debug mode is entered and more code
#	may be added with the 'e' command, which enters interactive entry mode.
#
#	In interactive mode the first column of octal numbers are output
#	by the assembler (input from keyboard, not from a file).
#	Labels are followed by a colon (:) and are optional.
#	White space can be 1 or more spaces or tabs.
#	When a program is run with the r command (no address), it starts
#	at 'main'. Alternatively use 100r to start this program.
#	Either way the Acummulator (LOC 0) and Carry (LOC 777) are cleared.
#
#		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#		;
#		;	Comment block
#		;
#		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#
#		LOC	10	; initialised data block
# 010	op1:	99
# 011	op2:	81
# 012	sum:	BLK	1	; uninitialised data block
# 013
#		LOC	100	; code block
# 100	main:	CLR	C	; clear carry before addition
# 101		LDA	op1
# 102		ADD	op2
# 103		STA	sum
# 104		PDN	sum
# 105		HLT
#
#	parameter1	pass 0 interactive, 1 define labels, 2 finish file assembly
#
#	two pass assembly for pass 1 and 2 to achieve a clean listing
#	single pass assembly for pass 0 to allow direct input from stdin or keyboard
#	NOTE: single pass assembly cannot handle address arithmetic with undefined
#	      symbolic names.
#
########################################################################

sub assembleFile {
    my ($pass) = @_;
    my ($key);
    my $eFlg = 0;
    $state = 0;				# state 0 none  1 data  2 code
    if (defined fileno IN) {
	while (<IN>) {					# input from file or stdin until EOF
	    chomp;					# remove new line
	    last if m/^\s*q$/ or m/^\s*__END__/;	# quit assembly
	    $eFlg += assembleLine($pass, $_);		# assemble a line
	}
    } else {
	while (defined ($_ = $term->readline(""))) {	# interactive input from keyboard until ctrl-d
	    last if m/^\s*q$/ or m/^\s*__END__/;	# quit assembly
	    $eFlg += assembleLine($pass, $_);		# assemble a line
	}
    }
    if ($pass == 0) {
	my $i = $eFlg;					# check for undefined symbols in interactive mode
	foreach $key (sort keys %symTable) {
	    if (($tmp = $symTable{$key}) & 01000) {
		print STDERR "\n" if $i == $eFlg;
		$tmp = sprintf "symbolic reference '%s' at loc %03o has not been defined", $key, $tmp & 0777;
		Error("$tmp", 1);
		$eFlg++;
	    }
	}
    }
    if ($pass != 1) {
	if ($pair[0] < ($pair[1] = $loc)) {		# any statements or data in this block ?
	    push @groups, [ @pair ];			# record the block
	}
	$pair[0] = $loc;				# in case another file is assembled
	if (scalar @lines) {
	    my ($arRef);
	    if (defined($arRef = $memSrc[01000])) {
		unshift @lines, @$arRef;		# old comments before new
	    } else {
		push @groups, [ 01000, 01001 ];		# comments after last code or data
	    }
	    $memSrc[01000] = [ @lines ];
	    @lines = ();
	}
    }
    if ($eFlg) {
	my $s = $eFlg >= 2 ? "s" : "";
	Error("$eFlg error$s during assembly - cannot run", 2);
    }
    return $eFlg;
} # assembleFile

########################################################################
#
#  Two pass assembly of a sigle line called from pass 1 or 2
#  One pass assembly of a sigle line called from pass 0 or debug()
#	parameter1	pass 0 interactive, 1 define labels, 2 finish file assembly
#	parameter2	$_ text to be assembled
#	parameter3	new location when called from debug() with <
#	return		error count
#
########################################################################

sub assembleLine {
    my ($pass, $newLoc);
    ($pass, $_, $newLoc) = @_;
    my ($label, $op, $num, $dval, $val, $locp, $locn, $blk, $str, $stmt, $arRef, $sym);
    my ($line, $i, $bs, $char, $byte, $char0, $byte0);
    my $errFlag = 0;
    my $termErrFlg = 0;
    $locn = $blk = $str = $dval = $val = undef;
    s/[ \t]+$//;					# remove trailing spaces and tabs
    $label = $line = "";
    if (defined $newLoc) {
	########################################################################
	#  One line assembly from debug with command < or
	#  Interactive code entry with readline()
	########################################################################
	if ($loc != $newLoc) {
	    if (@lines) {
		$memSrc[$loc] = [ @lines ];
		@lines = ();
	    }
	    if ($pair[0] < ($pair[1] = $loc)) {		# any statements or data in this block ?
		push @groups, [ @pair ];		# record the block
	    }
	    $pair[0] = $loc = $newLoc;			# one line assembly from debug
	    $state = 1;					# allow data or code line
	}
	########################################################################
	#  If overwriting a statement with a new assmbly line
	#    POP old statement first so it can be restored if line is only a comment.
	########################################################################
	unless (defined($arRef = $memSrc[$loc]) and
	    scalar(@lines = @$arRef) and
	    defined($stmt = pop @lines)) {
	    $stmt = undef;
	}
	########################################################################
	#    Get label if defined so new statement does not need to include the label
	########################################################################
	$label = defined($sym = $symbols{$loc}) ? "$sym:" : "";
    }
    $locp = $loc;					# previous location
    ## label common to all types of statements #############################
    if (m/^\s*([A-Za-z]\w*)\s*:/g) {
	if (not defined ($num = $symTable{$1})) {
	    goto StoreLabel;
	} elsif (($num & 01000) != 0) {
	    $num &= 0777;				# resolve reverse linked list in pass 0
	    do {
		$tmp = $mem[$num] & 0777;
		$mem[$num] &= ~0777;
		$mem[$num] |= $loc;
	    } while (($num = $tmp) != 0);
	  StoreLabel:
	    $symTable{$1} = $num = $loc;		# define symbolic reference
	    $symbols{$loc} = $1;			# inverse symbols for disassembly listing
	} elsif ($pass != 1 and $num != $loc) {
	    $tmp = sprintf "trying to redefine symbolic reference '%s' to %o from %o", $1, $loc, $num;
	    Error("$tmp");
	    $errFlag++;
	}
	$label = "$1:" if $num == $loc;			# for listing of "string"
    }
    ## code statement starting with an OP code followed by a MR ############
    if (m/\G \s*
	    ( [A-Z]+ ) \s*			# $1	op code
	    (					# $2	optional memory reference - default 0 ACC
		(				# $3
		    (@?) \s*			# $4	optional @ for indirect MR
		)
		(				# $5
		    ( [0-7]+ )			# $6	octal MR
		    |				#	or
		    (				# $7
			(			# $8
			    ( [A-Za-z]\w* )	# $9	symbolic MR label
			    |			#	or
			    ( \. )		# $10	current location for relative MR
			)
			( \s*			# $11	optional
			    ( [+-] )? \s*	# $12	sign - missing is error
			    ( \d+  )		# $13	decimal offset
			)?
		    )
		)
	    )?
	    (					# $14	optional comment (always defined)
		( \s* [;#].* )?			# $15
	    )
	$/x and
	defined($op = $opCodes{$1}[0]) ) {
	$num = 0;
	if ($2) {
	    if (defined $6) {
		$num = oct($6);					# octal memory reference
	    } else {
		if (defined $9) {
		    if (defined($tmp = $symTable{$9}) and	# symbolic memory reference
			($tmp & 01000) == 0) {			# not a reverse link in pass 0
			$num = $tmp;
		    } elsif ($pass == 0) {
			if (defined $tmp) {
			    $num = $tmp & 0777;			# build linked list
			}
			$symTable{$9} = $loc | 01000;		# link from this location
		    } elsif ($pass == 2) {
			$tmp = sprintf "%o", $loc;		# ignore pass 1
			Error("symbolic reference '$9' at loc $tmp has not been defined");
			$errFlag++;
		    }
		} elsif (defined $10) {
		    $num = $loc;				# '.' relative memory reference
		}
		if (defined $11) {
		    goto SynErr0 unless $12;
		    if ($12 eq '-') {
			$num -= $13;				# negative offset
		    } else {
			$num += $13;				# positive offset
		    }
		}
	    }
	    if ($pass != 1 and (($num &= 077777) >= (($opCodes{$1}[1] || $4) ? 0777 : 01000))) {
		$tmp = sprintf "mr %o is illegal %s at loc %o", $num, $num eq 0777 ? "carry" : "memory reference", $loc;
		Error("$tmp");
		$errFlag++;
		goto Err;
	    }
	}
	$val = $op | ($4 ? 01000 : 0) | $num;			# BALAD code statement
	$line = "$label\t$1 $2$14";
	$state = $op ? 2 : 1;					# follow with code or data if JMP
    ## HLT statement #######################################################
    } elsif (m/\G\s*HLT((\s*[;#].*)?)$/) {
	$val = 0;						# code HLT (JMP 0)
	$line = "$label\tHLT$1";
	$state = 1;						# end of code block
    ## LOC statement #######################################################
    } elsif (m/\G\s*(LOC)\s*([0-7]+)((\s*[;#].*)?)$/) {
	$num = oct $2;					# LOC statement	(octal argument)
	goto TestLOC;
    ## BLK statement #######################################################
    } elsif (m/\G\s*(BLK)\s*([1-9]\d*)((\s*[;#].*)?)$/) {
	$blk = $num = $loc + $2;				# BLK statement (decimal argument)
      TestLOC:
	$termErrFlg = $state;
	if ($pass != 1 and ($num <= 0 or $num >= 0777)) {
	    $num = sprintf "%o", $num;
	    Error("LOC $num; 0 and 777 are reserved, > 777 is illegal");
	    $errFlag++;
	    goto Err;
	} elsif ($pass >= 1 and $mem[$num]) {
	    goto MemERR2;					# LOC already initialised
	} else {
	    $locn = $num;					# LOC 01 to 0776 (modify previous loc)
	    if ($blk) {
		$line = "$label\t$1 $2$3";			# BLK looks like statement with opt label
	    } else {
		$line = "\t$1 $2$3";				# LOC looks like comment
		$locp = $locn;
		if ($pass != 1 and $locn != $loc) {		# end of a consecutive block
		    if ($pair[0] < ($pair[1] = $loc)) {		# any statements or data in this block ?
			push @groups, [ @pair ];		# record the block
		    }
		    $pair[0] = $locn;				# start of a new block
		}
	    }
	    $state = 1;
	}
    ## unsigned decimal number #############################################
    } elsif (m/\G\s*([1-9]\d*)([lL]?)((\s*[;#].*)?)$/) {
	$num = $1;						# unsigned decimal number
	goto TestNUM;
    ## octal, hexadecimal or binary number #################################
    } elsif (m/\G\s*(0[0-7]*)([lL]?)((\s*[;#].*)?)$/ or	# octal number
	     m/\G\s*(0[xX][0-9a-fA-F]+)([lL]?)((\s*[;#].*)?)$/ or # hexadecimal number
	     m/\G\s*(0[bB][01]+)([lL]?)((\s*[;#].*)?)$/) {	# binary number
	$num = oct $1;
      TestNUM:
	$termErrFlg = $state;
	if ($2) {
	    if ($num <= 07777777777) {
		$val  = $num & 077777;				# long number
		$dval = ($num >> 15) & 077777;
	    } elsif ($pass != 1) {
		Error("unsigned long number must be less than 1,073,741,824 (10000000000 octal)");
		$errFlag++;
		goto Err;
	    }
	} else {
	    if ($num <= 077777) {
		$val  = $num;					# short number
	    } elsif ($pass != 1) {
		Error("unsigned short number must be less than 32,768 (100000 octal)");
		$errFlag++;
		goto Err;
	    }
	}
	$line = "$label\t$1$2$3";
    ## signed decimal number ###############################################
    } elsif (m/\G\s*([-+])\s*(\d+)([lL]?)((\s*[;#].*)?)$/) {
	$num = $2;						# signed decimal number
	$termErrFlg = $state;
	if ($3) {
	    if ($num <= 03777777777) {				# long number
		$num  =  -$num & 07777777777 if $1 eq '-';
		$val  = $num & 077777;
		$dval = ($num >> 15) & 077777;
	    } elsif ($pass != 1) {
		Error("absolute value of long signed number must be less than 536,870,912 (4000000000 octal)");
		$errFlag++;
		goto Err;
	    }
	} else {
	    if ($num <= 037777) {				# short number
		$val  = $1 eq '-' ? -$num & 077777 : $num;
	    } elsif ($pass != 1) {
		Error("absolute value of short signed number must be less than 16,384 (40000 octal)");
		$errFlag++;
		goto Err;
	    }
	}
	$line = "$label\t$1$2$3$4";
    ## character "string" ##################################################
    } elsif (m/\G\s*"(.*)"((\s*[;#].*)?$)/) {
	$termErrFlg = $state;
	$str  = $1;						# character string
	$line = "$label\t\"$1\"$2";
    ## blank line or comment in a data block ###############################
    } elsif (m/\G((\s*[;#].*)?)$/) {
	$line = "$label$1";					# blank line or comment only
	$state   = 0 unless $state == 2;
    ## data not recognised #################################################
    } elsif ($pass != 1) {
      SynErr0:
	Error("syntax error - code or data not recognised");
	$errFlag++;
	goto Err;
    }
    ########################################################################
    #   End of one input line
    ########################################################################
    ########################################################################
    #   Store code or data in memory - check for address error
    #   Optionally list code or data produced
    ########################################################################
    my $optlpn = ($opt_l && $pass != 1) || defined $newLoc;
    if (defined $val) {						# single word of code or numeric data
	if ($loc > 0777 or ($pass >= 1 and $mem[$loc])) { goto MemERR1; }
	if ($optlpn) {
	    $tmp = sprintf "  %03o\t%05o\t%s", $loc, $val, $_;
	    List($tmp);
	}
	$mem[$loc] = $val if $pass != 1;
	$loc++;
	if (defined $dval) {					# high order word of numeric data
	    if ($loc > 0777 or ($pass >= 1 and $mem[$loc])) { goto MemERR1; }
	    if ($optlpn) {
		$tmp = sprintf "  %03o\t%05o", $loc, $dval;
		List($tmp);
	    }
	    $mem[$loc] = $dval if $pass != 1;
	    $loc++;
	}
    } elsif (defined $str) {					# "character string" (may be more than 1 word)
	$byte0 = $bs = $i = 0;
	foreach $char (split //, $str) {
	    $byte = ord $char;
	    if ($bs) {
		if (defined($tmp = $ascii_cntrl{$char})) {
		    $byte = ord $tmp;				# \ n  => "\n"  etc
		}
	    } elsif ($char eq "\\") {
		$bs = 1;
		next;
	    }
	    $bs = 0;						# all other chars following '\' unchanged
	    if ($byte0) {
		if ($loc > 0777 or ($pass >= 1 and $mem[$loc])) { goto MemERR1; }
		if ($optlpn) {
		    $tmp = sprintf "  %03o\t%05o", $loc, (($byte & 0177) << 8) + ($byte0 & 0177);
		    $tmp .= sprintf "\t%s", $_ if $i++ == 0;
		    List($tmp);
		}
		$mem[$loc] = (($byte & 0177) << 8) + ($byte0 & 0177) if $pass != 1;
		$loc++;
		$byte0 = 0;
	    } else {
		$byte0 = $byte;
	    }
	}
	if ($loc > 0777 or ($pass >= 1 and $mem[$loc])) { goto MemERR1; }
	if ($optlpn) {
	    $tmp = sprintf "  %03o\t%05o", $loc, ($byte0 & 0177);
	    $tmp .= sprintf "\t%s", $_ if $i++ == 0;
	    List($tmp);
	}
	$mem[$loc] = ($byte0 & 0177) if $pass != 1;
	$loc++;
    } elsif (defined $locn) {
	if ($optlpn) {
	    if ($blk) {
		$tmp = sprintf "  %03o\t00000\t%s", $loc++, $_;	# BLK
		List($tmp);
		while ($loc < $blk) {
		    $tmp = sprintf "  %03o\t00000", $loc++;	# BLK rest
		    List($tmp);
		}
	    } else {
		$tmp = sprintf "\t\t%s", $_;			# LOC
		List($tmp);
	    }
	}
	$loc = $locn;						# LOC or BLK - no data stored
    } elsif ($optlpn) {
	$tmp = sprintf "\t\t%s", $_;				# all other lines
	List($tmp);
    }
    if ($termErrFlg == 2) {
	## code not recognised or improper code block termination ##############
	$num = sprintf "%o", $loc;
	Error("code block not terminated by a JMP or HLT instruction at loc $num");
	$errFlag++;
    }
    goto Finish;
  MemERR0:
    print "\n";
    goto MemERR2;
  MemERR1:
    $num = $loc;
  MemERR2:
    $num = sprintf "%o", $num;
    Error("LOC $num illegal or already initialised with code or data");
    $errFlag++;
  Err:
    $line = $_;							# record line in case of error
    if ($opt_l) {
	$tmp = sprintf "\t\t%s", $_;				# all other lines
	List($tmp);
    }
  Finish:
    if ($pass != 1) {
	push @lines, $line;
	if ($loc == $locp) {
	    push(@lines, $stmt) if defined $stmt;		# restore old statement after new comment
	} else {
	    if ($pass == 2 and defined $memSrc[$locp]) {
		$tmp = sprintf "new code or data overwrites previous data in loc %03o", $locp;
		Error("$tmp", 1);
		$errFlag++;
	    }
	    $memSrc[$locp] = [ @lines ];
	    @lines = ();
	}
    }
    if ($pass == 0 and $opt_l and not defined $newLoc and $argv eq "keyboard input") {
	if ($state == 0) {
	    printf "\t";
	} else {
	    printf "%03o\t", $loc;
	}
    }
    return $errFlag;
} # assembleLine

########################################################################
#
#  mref - determine symbolic name from a memory reference
#    arg1: address of location
#    arg2: contents of the location
#
########################################################################

sub mref {
    my ($l, $m) = @_;
    my ($mref, $i);
    $m  &= 0777;
  mrefFound:
    until (defined($mref = $symbols{$m})) {
	for ($i = 1; $i < 8; $i++) {
	    if ($l == $m+$i) {
		$mref = ".-$i";
		last mrefFound;
	    }
	    if (defined($mref = $symbols{$m-$i})) {
		$mref .= "+$i";
		last mrefFound;
	    }
	    if ($l == $m-$i) {
		$mref = ".+$i";
		last mrefFound;
	    }
	}
	$mref = sprintf "%o", $m;
	last mrefFound;
    }
    return $mref;
} # mref

########################################################################
#
#  Debugger
#    arg1: 0 called before running a program
#	   1 called from a break
#	   2 called from a watch point
#
#    see help page for detailed command descriptions of the debugger
#
########################################################################

sub debug {
    my ($mode, $op, $mr) = @_;
    my ($listCmd, $lstart, $lfin, $l, $brkStar, $label, $sym, $stFlag, $num, $assIn, $i);
    $running = 2 if $running;			# stop interrupt with ctrl-\ key in debug
    if ($mode == 0) {
	$argv = "keyboard input";
	if ($filesAssd) {
	    if (defined($tmp = $symTable{'main'}) and not $opttdoxb) {
		########################################################################
		#  No essmbly errors in file(s) - run if main: defined and not -l -d -o -x -b
		########################################################################
		$pc = $loc = $tmp;		# start location defined in the assembled program
		if (defined $opt_B or not -t STDIN) {
		    if (not defined $opt_B or $opt_B eq "") {
			$argv = "STDIN",
			$opt_B = "-";
		    }
		    open IN, $opt_B or		# Batch data file
			die "can't open $opt_B ???";
		}
		run();				# run the code immediately
		close IN if $opt_B;
		exit() unless $abort == 1;	# only break if stopped with ctrl-\
	    } else {
		########################################################################
		#  else enter debugger
		########################################################################
		$loc = $tmp if defined $tmp;
		print "BALAD debugger - enter r to run code at 0100, e to enter more code interactively\n";
	    }
	} else {
	    ########################################################################
	    #  BALAD called without file arguments - enter code for interactive assembly
	    #  uses STDIN to allow < file.bl in command line
	    ########################################################################
	    if (-t STDIN) {
		$opt_l = 1;			# interactive input is best with listing
		print "Enter LOC and code or data interactively (q to return to debugger)\n\n\t";
	    } else {
		open IN, "-" or			# STDIN	- no source file arguments
		    die "can't open STDIN ???";
		$argv = "STDIN";			# enter first code or data
	    }
	    my $eF = assembleFile(0);		# interactive pass 0
	    if (-t STDIN) {
		print("\n");
	    } else {
		close(IN);
	    }
	    exit($eF) if $opt_c;		# quit BALAD after compile check
	}
    }
    ########################################################################
    #  entered debug proper after assembly or from a break or watch point
    ########################################################################
  Input:
    while (defined($tmp = sprintf "%03o %s ", $loc, $debPrompts[$mode]) and	# always true
	defined($_ = $term->readline("$tmp"))) {
	########################################################################
	#  These can be called in all modes
	########################################################################
	if (m/^\s*O(ut)?(\s+([A-Za-z]\w*(\.\w+)?))?$/) {
	    $tmp = $3 ? $3 : $opt_O;
	    if ($tmp and -e $tmp) {
		$_ = $term->readline("Output file $tmp exists, do you want to overwrite it ([y]n): ");
		next unless m/^([yY])?$/;
	    }
	    outText(0, $tmp);			# output source
	    next;
	}
	if (m/^\s*L(ist)?(\s+([A-Za-z]\w*(\.\w+)?))?$/) {
	    $tmp = $3 ? $3 : $opt_L;
	    if ($tmp and -e $tmp) {
		$_ = $term->readline("List file $tmp exists, do you want to overwrite it ([y]n): ");
		next unless m/^([yY])?$/;
	    }
	    outText(1, $tmp);			# output listing
	    next;
	}
	if (m/^\s*S(ym)?$/) {
	    outSymTab();			# output Symbol Table
	    next;
	}
	if (m/^\s*H(elp)?$/) {
	    appHelp();				# output application help text
	    next;
	}
	if (m/^\s*h(elp)?$/) {
	    write STDOUT;			# output Debugger help text
	    next;
	}
	if (m/^\s*q(uit)?$/) {
	    exit;				# quit BALAD
	}
	if ($_ !~ m/^([A-Za-z]\w*)$/ or $1 =~ m/^([resnuca])$/) { # allow addresses ending in 'r' etc
	    if ($mode == 0) {			# bypass simple addresses except 'r' 'e' 's' 'n' etc
		if (m/^\s*e(nter)?$/) {		# enter command (must be first - otherwise label 'e')
		    ########################################################################
		    #  enter more code or data
		    #  uses $term->readline() to force keyboard input
		    ########################################################################
		    $argv = "keyboard input";
		    $opt_l = 1;			# interactive input is best with listing
		    print "Enter LOC and code or data interactively (q to return to debugger)\n\n\t";
		    assembleFile(0);		# interactive pass 0
		    print("\n");
		    next;
		}
		########################################################################
		#  optional octal address or symbolic MR label or . +|- optional offset
		########################################################################
		if (m/^ \s*
		    (					# $1	optional
			(  @ \s*)?			# $2	optional @ for indirect address
			(				# $3	address
			    ( [0-7]+ )			# $4	octal MR
			    |				#	or
			    (				# $5
				(			# $6
				    ( [A-Za-z]\w* )	# $7	symbolic MR label
				    |			#	or
				    ( \. )		# $8	current location for relative MR
				)
				( \s*			# $9	optional
				    ( [+-] ) \s*	# $10	sign - missing is error
				    ( \d+  )		# $11	decimal offset
				)?
			    )
			) \s*
		    )?  r(un)?				# $12	 run command
		$/x) {
		    ########################################################################
		    #  r          run BALAD code from default start address 'main' or 0100
		    #  <octal> r  run BALAD code from octal address
		    #  <label> [ +|-<n>] r  run BALAD code from a symbolic address
		    #  .       [ +|-<n>] r  run BALAD code from a relative address
		    ########################################################################
		    if (not defined $1 or $1 eq "") {
			$num = defined($tmp = $symTable{'main'}) ? $tmp : 0100;	# default start address
		    } elsif (defined $4) {
			$num = oct($4);			# octal memory reference
		    } else {
			if (defined $7) {
			    if (defined($tmp = $symTable{$7})) {# symbolic memory reference
				$num = $tmp;
			    } else {
				warn "??? symbolic reference '$7' has not been defined\n";
				next;
			    }
			} elsif (defined $8) {
			    $num = $loc;		# '.' relative memory reference
			}
			if (defined $9) {
			    if ($10 eq '-') {
				$num -= $11;		# negative offset
			    } elsif ($10 eq '+') {
				$num += $11;		# positive offset
			    }
			}
		    }
		    if ($num > 0777) {
			warn"??? memory limit is octal 777\n";
			next;
		    }
		    $pc = (defined $2) ? ($mem[$num] & 0777) : $num;	# @address : address
		    $opt_B = "";			# can no longer accept Batch data
		    run();
		    next;
		}
	    } else {
		########################################################################
		#  entered from break in executing code (mode >= 1)
		#	s	step one instruction	- into JMS subroutine
		#	n	next instruction	- skip over JMS subroutine
		#	u	until return out of current JMS subroutine
		#	c	continue until next break or watch point
		#	a	abort execution		- stop program running
		########################################################################
		$break = 0;
		if (m/^\s*([snuca])$/) {
		    if ($1 eq 's') {			# single step
			$break = 1;
		    } elsif ($1 eq 'n') {		# next unless JMS at a break point
			if ($op != 01 or $mode != 1) {
			    $break = 1;
			} else {
			    $jmsCall = $mr;		# defer breaks until return from this JMS
			}
		    } elsif ($1 eq 'u') {		# run until return from current JMS
			$jmsCall = $jmsStack[$#jmsStack] if scalar @jmsStack;
		    } elsif ($1 eq 'a') {		# abort execution
			$abort = 1;
		    }
		    goto stopDebug;			# continue ('c' is none of the above)
		} elsif (m/((r(un)?)|(e(nter)?))$/) {
		    $tmp = $2 ? "run" : "enter";
		    $sym = $mode == 1 ? "break" : "watch";
		    warn "??? cannot $tmp a program from a $sym point - exit first with 'a'\n";
		    next;
		}
	    }
	}
	########################################################################
	#  optional address or address range for all following debug commands
	########################################################################
	if (m/^
	    (   \s*				# $1  optional address
		(  @ \s*)?			# $2	optional @ for indirect address
		(				# $3  start of range
		    ( [0-7]+ )			# $4	octal MR
		    |				#	or
		    (				# $5
			(			# $6
			    ( [A-Za-z]\w* )	# $7	symbolic MR label
			    |			#	or
			    ( \. )		# $8	current location for relative MR
			)
			( \s*			# $9	optional
			    ( [+-] ) \s*	# $10	sign - missing is error
			    ( \d+  )		# $11	decimal offset
			)?
		    )
		)
		(   \s*,\s*			# $12 optional
		    (  @ \s*)?			# $13	optional @ for indirect address
		    (				# $14 end of range
			( [0-7]+ )		# $15	octal MR
			|			#	or
			(			# $16
			    (			# $17
				( [A-Za-z]\w* )	# $18	symbolic MR label
				|		#	or
				( \. )		# $19	current location for relative MR
			    )
			    ( \s*		# $20	optional
				( [+-] ) \s*	# $21	sign - missing is error
				( \d+  )	# $22	decimal offset
			    )?
			)
		    )
		)?
	    )?  \s*
	    (					# $23 optional empty command - list
		( [*#=<\/] )			# $24 command selection
		( [cduoxbDUOXBsS] )?		# $25 optional list mode selection
		( .* )				# $26 optional assembly input
	    )?
	$/x) {
	    ########################################################################
	    #  act on or list 1 or more memory locations in selected list mode
	    ########################################################################
	    $listMode = $lM;			# restore list mode and offset after temporary change
	    $listOfs  = $lO;			# when manipulating breakpoints or doing an assembly line
	    $lstart = $lfin = $loc;		# defaults if no address or range is specified
	    $assIn = "";
	    if ($23) {
		$listCmd = $24;
		if ($listCmd ne '<' and defined $26 and $26 ne "") {
		    warn "??? '$listCmd' command does not accept assembly code '$26'\n";
		    next;
		} else {
		    $assIn = $26;
		}
	    } else {
		$listCmd = '/';
	    }
	    if (defined $1 and $1 ne "") {
		if (defined $4) {				# start of range
		    $num = oct($4);				# octal memory reference
		} else {
		    if (defined $7) {
			if (defined($tmp = $symTable{$7})) {	# symbolic memory reference
			    $num = $tmp;
			} elsif ($7 =~ m/^([snuca])$/) {
			    warn "??? command '$1' can only be called at a break or watch point\n";
			    next;				# s n u c a in symbol table have precedence
			} else {
			    warn "??? symbolic reference '$7' has not been defined\n";
			    next;
			}
		    } elsif (defined $8) {
			$num = $loc;				# '.' relative memory reference
		    }
		    if (defined $9) {
			if ($10 eq '-') {
			    $num -= $11;			# negative offset
			} elsif ($10 eq '+') {
			    $num += $11;			# positive offset
			}
		    }
		}
		if ($num > 0777) {
		    warn"??? memory limit is octal 777\n";
		    next;
		}
		$lstart = $lfin = (defined $2) ? ($mem[$num] & 0777) : $num;	# @address : address
		if (defined $12) {
		    if (defined $15) {				# optional end of range
			$num = oct($15);			# octal memory reference
		    } else {
			if (defined $18) {
			    if (defined($tmp = $symTable{$18})) {	# symbolic memory reference
				$num = $tmp;
			    } else {
				warn "??? symbolic reference '$18' has not been defined\n";
				next;
			    }
			} elsif (defined $19) {
			    $num = $loc;			# '.' relative memory reference
			}
			if (defined $20) {
			    if ($21 eq '-') {
				$num -= $22;			# negative offset
			    } elsif ($21 eq '+') {
				$num += $22;			# positive offset
			    }
			}
		    }
		    if ($num > 0777) {
			warn"??? memory limit is octal 777\n";
			next;
		    }
		    $lfin = (defined $13) ? ($mem[$num] & 0777) : $num;	# @address : address
		}
	    } elsif ($listCmd eq '=' or $listCmd eq '#') {
		$lstart = 0;			# full range for listing break points
		$lfin   = 0777;
	    }
	    if ($lstart > $lfin) {
		warn"??? listing range must be rising\n";
		next;				# $loc unchanged
	    }
	    if ($listCmd eq '<') {
		if ($25) {			# change list mode and offset temporarily for an assembly line
		    $assIn = "$25$assIn";		# no list mode after < - fixes BLK and DEC
		}
		if ($assIn =~ m/^\s*([A-Za-z]\w*\s*:\s*)?[A-Z][A-Z][A-Z]/) {
		    $listMode = 'c';			# code
		    $listOfs = 1;
		} elsif ($assIn =~ m/^\s*([A-Za-z]\w*\s*:\s*)?([+-]\s*)?\d/) {
		    $tmp = $2;				# + or - sign
		    if ($assIn =~ m/[lL]\s*([;#].*)?$/) {
			$listMode = $tmp ? 'D' : 'U';	# long number
			$listOfs = 2;
		    } else {
			$listMode = $tmp ? 'd' : 'u';	# short number
			$listOfs = 1;
		    }
		} elsif ($assIn =~ m/^\s*([A-Za-z]\w*\s*:\s*)?".*"/) {
		    $listMode = 's';			# string
		    $listOfs = 1;
		} elsif ($assIn !~ m/^\s*([;#].*)?$/) {	# ignore comment only
		    warn "??? cannot assemble '$assIn'\n";
		    next;			# $loc unchanged
		}
		if ($listMode eq 's' or $listMode eq 'S') {
		    $lfin = $lstart;		# cannot assemble more than one string
		}
	    } elsif ($25) {
		    $listMode = $lM = $25;	# change list mode for all other commands
		    $listOfs = $lO = ($listMode =~ m/[DUOXB]/) ? 2 : 1;	# and offset
	    } elsif ($listCmd eq '*' or $listCmd eq '=' or $listCmd eq '#') {
		$listMode = 'c';		# change list mode to code temporarily
		$listOfs = 1;			# unless specifically specified by d u o x b
	    }					# avoid D U O X B because of $listOfs 2
	    $stFlag = 1;
	    for ($l = $lstart; $l <= $lfin; $l += $listOfs) {
		########################################################################
		#  select command
		########################################################################
		if ($listCmd eq '*') {
		    $breaks[$l] = 1;		# set a break or watch point and list
		} elsif ($listCmd eq '#') {
		    if ($breaks[$l] == 1) {
			$breaks[$l] = 0;	# clear a break or watch point and list
		    } else {
			next;			# skip unless break or watch point was set
		    }
		} elsif ($listCmd eq '=') {
		    next if $breaks[$l] != 1;	# list break or watch points
		}
		$brkStar = $breaks[$l] ? " *" : "";
		$label = defined($sym = $symbols{$l}) ? "$sym:" : "";
		$tmp = $mem[$l];
		printf "  %03o%s\t%05o\t%s\t", $l, $brkStar, $tmp, $label;
		$tmp += ($mem[$l+1] << 15) if $listOfs == 2;
		########################################################################
		#  select list mode
		########################################################################
		if ($listMode eq 'c') {		# list as balad code
		    my ($opc, $ind);
		    if ($tmp == 0) {		# 0 instead of JMP ACC or HLT
			print "0\n";
		    } else {
			$opc   = $opNames[($tmp & 076000) >> 10];
			$ind   = $tmp & 01000 ? '@' : "";
			printf "%s %s%s\n", $opc, $ind, mref($l, $tmp);
		    }
		} elsif ($listMode eq 'd') {
		    $tmp |= -040000 if $tmp & -040000;	# extend sign
		    printf "%6d\n", $tmp;	# list as short signed decimal
		} elsif ($listMode eq 'u') {
		    printf "%6u\n", $tmp;	# list as short unsigned decimal
		} elsif ($listMode eq 'o') {
		    printf "%#6o\n", $tmp;	# list as short unsigned octal
		} elsif ($listMode eq 'x') {
		    printf "%#06x\n", $tmp;	# list as short unsigned hexadecimal
		} elsif ($listMode eq 'b') {
		    printf "%015b\n", $tmp;	# list as short unsigned binary
		} elsif ($listMode eq 'D') {
		    $tmp |= -04000000000 if $tmp & -04000000000;	# extend sign
		    printf "%10ld\n", $tmp;	# list as long signed decimal
		} elsif ($listMode eq 'U') {
		    printf "%9lu\n", $tmp;	# list as long unsigned decimal
		} elsif ($listMode eq 'O') {
		    printf "%#11lo\n", $tmp;	# list as long unsigned octal
		} elsif ($listMode eq 'X') {
		    printf "%#010lx\n", $tmp;	# list as long unsigned hexadecimal
		} elsif ($listMode eq 'B') {
		    printf "%030lb\n", $tmp;	# list as long unsigned binary
		} elsif ($listMode eq 's' or $listMode eq 'S') {
		    my ($byte0, $byte1, $ch, $st);	# list as text string
		    $byte0 = $tmp & 0177;
		    $byte1 = ($tmp & 077400) >> 8;
		    if ($listMode eq 's') {
			$ch = chr $byte0;
			printf "%s ", defined($st = $cntrl_slash{$ch}) ? $st : $ch;
			$ch = chr $byte1;
			printf "%s", defined($st = $cntrl_slash{$ch}) ? $st : $ch;
		    }
		    if ($stFlag) {
			my $string = convString($l, 1);	# global $cmr returns address of next word
			if ($cmr > $lfin) {
			    $lfin = $cmr;		# extend listing to end of current string
			}
			if ($listMode eq 'S') {
			    print "\"$string\"";
			    $l = $cmr;			# skip octal listing to end of string
			} else {
			    print "\t\"$string\"";
			    $stFlag = 0;
			}
		    }
		    print "\n";
		    if ($byte0 == 0 or $byte1 == 0) {
			$stFlag = 1;		# end of current string found - start another
		    }
		}
		########################################################################
		#  end of list modes - default is simple list like /
		#  list hi order byte of a double precision number
		########################################################################
		printf("  %03o\t%05o\n", $l+1, $mem[$l+1]) if $listOfs == 2;
		if ($listCmd eq '<' and $stFlag) {
		    ########################################################################
		    #  Assemble one code statement, one single or double precision number
		    #  which my be signed or unsigned decimal, octal, hexadcimal or binary,
		    #  or one string, which may write a number of words. The format and
		    #  restrictions are the same for BALAD source files, interactive
		    #  entry or this single line debug entry. They all call the same assembler.
		    #  The only difference is, that locations are defined by the debug address
		    #  before the < command like all other debug commands and not by LOC
		    #  or BLK statements.
		    #
		    #  This input to modify words in memory is for the purpose of debugging
		    #  and will mainly involve changing data. If just a single instruction
		    #  has to be changed - like changing the sense of a conditional JMP that
		    #  should be OK. If more code is to be changed that is probably better
		    #  done in interactive entry mode or if instructions have to be inserted,
		    #  editing the source file and calling BALAD with the modified source.
		    ########################################################################
		    if ($assIn =~ m/^\s*(LOC|BLK)/) {
			warn "??? LOC or BLK have no effect in debug single line assembly\n";
			next Input;
		    }
		    ## assemble a line out of debug ########################################
		    if (assembleLine(0, $assIn, $listMode eq 's' || $listMode eq 'S' ? $lstart : $l) or
			$assIn =~ m/^\s*([;#].*)?$/) {
			next Input;			# errors or comment - $loc unchanged
		    }
		    $l = $loc - $listOfs;		# take $loc from assembly
		    $lfin = $l if $listMode eq 's'	# $lfin was from old string, which may be longer
			       or $listMode eq 'S';	# which led to an infinite loop
		}
	    }
	    $loc = $l if $listCmd eq '/' or $listCmd eq '<';	# $loc for '*' '#' '=' unchanged
	} elsif (m/^\s*-(t?)([doxb]?)$/) {
	    ########################################################################
	    #  change trace modes
	    #    -	no tracing
	    #    -t	only list code
	    #    -to	plus trace C, ACC, MR as octal
	    #    -o	plus trace C, ACC, MR as octal only at break points
	    #    Similarly for -td -d -tx -x -tb -b
	    ########################################################################
	    $opt_t = $1;
	    $opt_o = $opt_d = $opt_x = $opt_b = "";
	    if ($2 eq 'o') {
		$opt_o = $2;
		$traceFormat = "%sC %d ACC %05o [%03o] %05o";
	    } elsif ($2 eq 'd') {
		$opt_d = $2;
		$traceFormat = "%sC %d ACC %5d [%03o] %5d";
	    } elsif ($2 eq 'x') {
		$opt_x = $2;
		$traceFormat = "%sC %d ACC x%04x [%03o] x%04x";
	    } elsif ($2 eq 'b') {
		$opt_b = $2;
		$traceFormat = "%sC %d ACC %015b [%03o] %015b";
	    }
	    $optlx =  $opt_t && ($opt_o || $opt_d || $opt_x || $opt_b);
	    $optnx = !$opt_t && ($opt_o || $opt_d || $opt_x || $opt_b);
	} else {
	    warn "???\n";
	}
    }
    if (not defined $_) { print "\n"; $abort = 1 if $mode; }	# ctrl-D
  stopDebug:
    $running = 1 if $running;
} # debug

########################################################################
#
#   Run BALAD code
#	@mem	512 words of BALAD memory from $mem[0] to $mem[0777]
#	$mem[0]		ACC	accumulator register
#	$mem[0777]	C	carry register
#	$jR			jump tester result
#	$jC			jump tester carry
#	$pc			program counter
#
########################################################################

sub run {
    my ($t0, $t1, $sec, $usec);
    my ($instr, $op, $at, $num, $next, $jmsFlag, $n, $watch, $mv, $label, $jmsMr, $sym);
    if ($eF) {
	warn "*** ERROR: cannot run because of previous $eF assembly errors\n";
	exit;
    }
    $mem[0] = $mem[0777] = $jR = $jC = $jmsCall = $break = $next = $abort = 0;	# clear ACC, C and jump testers
    @jmsStack = ();
    $jmsMr = 0;
    $running = 1;
    printf ("\t%3o *****  run *****\n", $pc) if $opt_t;
    my $iCnt = 0;
    if ($opt_m) {
	$t0 = [gettimeofday];
    }
    ########################################################################
    #   Start execution with instruction at $pc
    ########################################################################
    while (($instr = $num = $mem[$pc]) != 0) {		# fetch instruction (0 is HLT)
	$iCnt++;					# count instructions executed for -m statistics
	$break |= $breaks[$pc];				# extract break point
	$op = ($instr & 076000) >> 10;			# op code
	$at = $instr & 01000;				# @
	$mr = $tmp = $num & 0777;			# direct memory reference
	########################################################################
	#   Check for indirect memory reference
	########################################################################
	for ($n = 0; $num & 01000; $mr = $num & 0777) {
	    if ($op < 010) {
		$jmsFlag = ($jmsCall == $mr);
		$next = $pc + 1;			# a possible JMS return
	    }
	    $num = $mem[$mr];				# @ indirect memory reference
	    if ($n++ > 10) {
		$num = sprintf "%o", $mr;
		warn "*** EXEC ERROR: very long indirect loop at LOC $num\n";
		goto stopRun;
	    }
	}
	$watch = $breaks[$mr] && $opTrace[$op];
	$opttx = $optlx || ($optnx && ($break || $watch ||	# trace at break or watch point
		 $breaks[$pc+1] && $ocTrace[($mem[$pc+1] & 076000) >> 10]));	# or break before conditional jmp
	if ($opt_t or $opttx) {
	    if ($jmsMr) {
		if ($jmsMr == $pc-1) {			# trace the start of a subroutine if stepping into it
		    printf("\n%s\t%03o %5o\n", defined($sym = $symbols{$jmsMr}) ? "$sym:" : "", $pc-1, $mem[$pc-1]);
		}					# ignore if stepping over subroutine
		$jmsMr = 0;
	    }
	    $label = defined($sym = $symbols{$pc}) ? "$sym:" : "";
	    printf("%s\t%3o %05o  %3s %s%s", $label, $pc, $instr, $opNames[$op], $at ? "@" : "", mref($pc, $tmp));
	    if ($op <= 7) {				# JMP JMS JZR JNR etc
		if ($op == 01) {
		    $jmsMr = $mr;			# JMS start for extra trace if stepping into subroutine
		} elsif ($at) {				# except JMS
		    print "\n";				# JMP @ - usually a subroutine return
		}
	    }
	}
	$mv = $mem[$mr];				# value at $mr before execution for watch point check
	#### trace before execution ############################################
	if ($opttx) {
	    if ($opTrace[$op]) {			# ignore JMP and Print instructions for trace
		printf ($traceFormat, "\t", $mem[0777], $mem[0], $mr, $mv);
	    } elsif ($op == 037) {
		printf("\t\"%s\"", convString($mr, 1));# PRF trace dressed format string
	    }
	}
	########################################################################
	#   Check for breakpoint
	########################################################################
	if ($break) {
	    $loc = $pc;
	    print "\n" if $opt_t or $opttx;
	    debug(1, $op, $mr);
	    goto stopRun if $abort;			# may be set in debug()
	    print "\t\t\t\t\t\t\t " if $opttx and $opTrace[$op];
	} elsif ($opt_t and not ($opttx and $opTrace[$op])) {
	    print "\n";					# terminate trace before JMP and Print instructions
	}
	########################################################################
	#   Exeute instruction
	########################################################################
	$pc++;						# next instruction (unless modified by JMP)
	$opSubs[$op]->();				# execute op code (all op's exist) with resolved $mr
	goto stopRun if $abort;				# may be set in KDN, KDD, KCH or KCS
	if ($next) {
	    if ($next != $pc) {				# is jump to next instruction ?
		if ($jmsFlag) {				# no - jump was true and jumped somewhere else
		    $break = 1;				#      return from JMS subroutine after n - next
		    $jmsCall = 0;
		}
		pop @jmsStack;				# for u - until
	    }
	    $next = 0;
	}
	#### trace after execution #############################################
	if ($opttx and $opTrace[$op]) {			# ignore JMP and Print instructions for trace
	    printf ($traceFormat, " ==> ", $mem[0777], $mem[0], $mr, $mem[$mr]);
	    printf ("  jC %d jR %d%s\n", $jC, $jR ? 1 : 0, $watch ? "  watch" : "");
	}
	########################################################################
	#   Check for watch point change of value at $mr
	########################################################################
	if ($watch and $mv != $mem[$mr]) {
	    $loc = $mr;
	    debug(2, $op, $mr);
	    goto stopRun if $abort;			# may be set in debug()
	}
    }
    ########################################################################
    #   Exeution finished - reached HLT instruction
    ########################################################################
    printf ("\t%3o *****  HLT *****\n", $pc) if $opt_t;
  stopRun:
    $running = 0;
    if ($opt_m) {
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
      no integer;
	my $av = ($sec*1000000 + $usec) / $iCnt;
	printf "%3d.%03d,%03d seconds for %d instructions (average %5.3f usec)\n", $sec, int($usec/1000), $usec%1000, $iCnt, $av;
      use integer;
    }
} # run

########################################################################
#
#   Functions to execute each op-code
#
########################################################################


sub JMP {		# 000000
    $pc = $mr;
} # JMP

sub JMS {		# 002000
    $mem[$mr] = $pc;	# save return address
    push @jmsStack, $mr;# record JMS calls on a stack
    $pc = $mr + 1;
} # JMS

sub JZR {		# 004000
    $pc = $mr if $jR == 0;
} # JZR

sub JNR {		# 006000
    $pc = $mr if $jR != 0;
} # JNR


sub JZC {		# 010000
    $pc = $mr if $jC == 0;
} # JZC

sub JNC {		# 012000
    $pc = $mr if $jC != 0;
} # JNC

sub JEZ {		# 014000
    $pc = $mr if $jR == 0 or $jC == 0;
} # JEZ

sub JBN {		# 016000
    $pc = $mr if $jR != 0 and $jC != 0;
} # JBN


sub AND {		# 020000
    $jR = $mem[0] &= $mem[$mr];	# and accumulator (carry not affected)
} # AND

sub ADD {		# 022000
    $jR = $mem[0] + $mem[0777] + $mem[$mr];	# add to accumulator and carry
    if ($jR & ~077777) {		# overflow ?
	$jR &= 077777;			# yes - mask accumulator
	$jC = $mem[0777] = 1;		# set carry
    } else {
	$jC = $mem[0777] = 0;		# clear carry
    }
    $mem[0] = $jR;
} # ADD

sub SUB {		# 024000
    $jR = $mem[0] + ($mem[0777] ^ 1) + ($mem[$mr] ^ 077777);	# add twos complement to accumulator and carry
    if ($jR & ~077777) {		# overflow ?
	$jR &= 077777;			# yes - mask accumulator
	$jC = $mem[0777] = 0;		# clear carry
    } else {
	$jC = $mem[0777] = 1;		# set carry
    }
    $mem[0] = $jR;
} # SUB

sub CMP {		# 026000
    $jR = $mem[0] + 1 + ($mem[$mr] ^ 077777);	# add twos complement to accumulator (carry cleared)
    if ($jR & ~077777) {		# overflow ?
	$jR &= 077777;			# yes - mask accumulator in jump tester only
	$jC = 1;			# set carry in jump tester only
    } else {
	$jC = 0;
    }
} # CMP


sub LDA {		# 030000
    $jR = $mem[0] = $mem[$mr];		# load accumulator
} # LDA

sub STA {		# 032000
    $jR = $mem[$mr] = $mem[0];		# store accumulator
    $jC = $mem[0777] &= 1 if $mr == 0777; # may set or reset carry
} # STA

sub CLR {		# 034000
    $jR = $mem[$mr] = 0;		# clear memory location
    $jC = 0 if $mr == 0777;		# may also clear carry
} # CLR

sub TST {		# 036000
    $jR = $mem[$mr];
    $jC = $mem[0777] & 1 if $mr == 0777; # may test carry
} # TST


sub COM {		# 040000
    $jR = $mem[$mr] = $mem[$mr] ^ 077777;	# bitwise complement memory location
    $jC = $mem[0777] &= 1 if $mr == 0777;	# may also complement carry
} # COM

sub NEG {		# 042000
    $jR = ($mem[0777] ^ 1) + ($mem[$mr] ^ 077777); # twos complement memory location
    if ($jR & ~077777) {		# overflow ?
	$jR &= 077777;			# yes - mask accumulator
	$jC = $mem[0777] ^= 000001;	# complement carry
    }
    $mem[$mr] = $jR;
} # NEG

sub INC {		# 044000
    $jR = $mem[$mr] + 1;
    if ($jR & ~077777) {
	$jR &= 077777;			# yes - mask accumulator
	$jC = $mem[0777] ^= 000001;	# complement carry
    } else {
	$jC = $mem[0777];		# no change in carry
    }
    $mem[$mr] = $jR;
} # INC

sub DEC {		# 046000
    $jR = $mem[$mr] - 1;
    if ($jR & ~077777) {
	$jR &= 077777;			# yes - mask accumulator
	$jC = $mem[0777] ^= 000001;	# complement carry
    } else {
	$jC = $mem[0777];		# no change in carry
    }
    $mem[$mr] = $jR;
} # DEC


sub ROL {		# 050000	# shift operators should not operate on carry
    $jR = ($mem[$mr] << 1) + $mem[0777];
    $jC = $mem[0777] = $jR >> 15;
    $mem[$mr] = $jR &= 077777;
} # ROL

sub ROR {		# 052000
    $jC = $mem[$mr] & 000001;
    $jR = ($mem[$mr] >> 1) + ($mem[0777] << 14);
    $mem[$mr] = $jR;
    $mem[0777] = $jC;
} # ROR

sub ASR {		# 054000
    $jC = $mem[$mr] & 000001;
    $jR = $mem[$mr];
    $jR += (($jR & 040000) << 1);
    $mem[$mr] = $jR >>= 1;
    $mem[0777] = $jC;
} # ASR

sub SWP {		# 056000
    $jR = (($tmp = $mem[$mr]) & 0177) << 8;
    $mem[$mr] = $jR += $tmp >> 8;
} # SWP


sub KDN {		# 060000
    print "\n" if $opttx;
    my $prompt = ($tmp = $mem[0776] & 0777)
		   ? convString($tmp, 0)
		   : "Enter a short number";
  RepeatKDN:
    if ($opt_B) {
	$_ = <IN>;
	if (defined $_) {
	    print "$prompt: $_";
	    chomp $_;
	}
    } else {
	$_ = $term->readline("$prompt: ");
    }
    if (not defined $_ or $_ eq "q") {
	print "\n" if not defined $_;
	$abort = 2;				# ctrl-D or q
	return;
    }
    s/(^\s+|,|\s+$)//g;
    my $o = 0;
    $jR = m/^0/ ? ($o = 1, oct $_) : +$_;
    if ($jR =~ m/[^0-9+-]/) {
	warn "*** ERROR: '$jR' is not a numeric integer\n";
	$prompt = "Try again";
	goto RepeatKDN;
    }
    if ($jR > ($o ? 077777 : 037777) or $jR < ~037777) {
	warn "*** ERROR: short number '$jR' must be between -16,384 and +16,383\n";
	$prompt = "Try again";
	goto RepeatKDN;
    }
    $mem[$mr] = $jR & 077777;
    print "\t\t\t\t\t\t\t " if $opttx;
} # KDN

sub KDD {		# 062000
    print "\n" if $opttx;
    my $prompt = ($tmp = $mem[0776] & 0777)
		   ? convString($tmp, 0)
		   : "Enter a long number";
  RepeatKDD:
    if ($opt_B) {
	$_ = <IN>;
	if (defined $_) {
	    print "$prompt: $_";
	    chomp $_;
	}
    } else {
	$_ = $term->readline("$prompt: ");
    }
    if (not defined $_ or $_ eq "q") {
	print "\n" if not defined $_;
	$abort = 2;				# ctrl-D or q
	return;
    }
    s/(^\s+|,|\s+$)//g;
    my $o = 0;
    $jR = m/^0/ ? ($o = 1, oct $_) : +$_;
    if ($jR =~ m/[^0-9+-]/) {
	warn "*** ERROR: '$jR' is not a numeric integer\n";
	$prompt = "Try again";
	goto RepeatKDD;
    }
    if ($jR > ($o ? 07777777777 : 03777777777) or $jR < ~03777777777) {
	warn "*** ERROR: long number '$jR' must be between -536,870,912 and +536,870,911\n";
	$prompt = "Try again";
	goto RepeatKDD;
    }
    $mem[$mr] = $jR & 077777;			# long number
    $mem[$mr+1] = ($jR >> 15) & 077777;
    print "\t\t\t\t\t\t\t " if $opttx;
} # KDD

sub KCH {		# 064000
    print "\n" if $opttx;
    ReadMode('cbreak');
    my $byte = $opt_B ? getc(IN) : ReadKey(0);	# single character from Batch file or keyboard
    if (not defined $byte or ord($byte) == 04) {
	ReadMode('normal');			# # ctrl-D
	print "\n";
	$abort = 2;
	return;
    }
    ReadMode('normal');
    $jR = $mem[$mr] = ord $byte;		# do not echo single character input
    print "\t\t\t\t\t\t\t " if $opttx;
} # KCH

sub KCS {		# 066000
    print "\n" if $opttx;
    my ($num, $char, $bs, $byte, $char0, $bs0, $byte0);
    my $ms = $mr;
    my $prompt = ($tmp = $mem[0776] & 0777)
		   ? convString($tmp, 0)
		   : "Enter a text string";
  RepeatKCS:
    if ($opt_B) {
	$_ = <IN>;
	if (defined $_) {
	    print "$prompt: $_";
	    chomp $_;
	}
    } else {
	$_ = $term->readline("$prompt: ");
    }
    if (not defined $_ or $_ eq "q") {
	print "\n" if not defined $_;
	$abort = 2;				# ctrl-D or q
	return;
    }
    $char0 = '';
    $byte0 = $bs0 = $bs = $jR = 0;
    foreach $char (split //, $_) {
	$byte = ord($char);
	if ($bs) {
	    if ($byte == 0156) {
		$byte = 012;			# "\n"  LF
	    } elsif ($byte == 0164) {
		$byte = 011;			# "\t"  HT
	    }
	} elsif ($byte == 0134) {
	    $bs   = 0134;			# '\'
	    next;
	} elsif ($byte == 011) {
	    $char = "\\t";			# real HT display as "\t"
	}
	if ($byte0) {
	    if ($mr >= 0776) { goto KCSERR0; }
	    $num = (($byte & 0177) << 8) + ($byte0 & 0177);
	    printf("\t%03o\t%05o\t%c%s %c%s\n", $mr, $num, $bs0, $char0, $bs, $char) if $opttx;
	    $mem[$mr++] = $num;
	    $byte0 = 0;
	    $char0 = '';
	    $bs0   = 0;
	} else {
	    $byte0 = $byte;
	    $char0 = $char;
	    $bs0   = $bs;
	}
	$bs = 0;				# all other chars following '\' unchanged
    }
    if ($mr >= 0776) { goto KCSERR0; }
    $num = ($byte0 & 0177);
    printf("\t%03o\t%05o\t%c%s\n\t\t\t\t\t\t\t ", $mr, $num, $bs0, $char0) if $opttx;
    $mem[$mr] = $num;					# last terminating word
    $jR = (($tmp = $mem[$ms]) != 0 && $tmp != 060);	# "" or "0" but not "00" are false
    return;
  KCSERR0:
    warn "*** ERROR: String will overflow memory\n";
    $prompt = "Try again with a shorter string";
    $mr = $ms;
    goto RepeatKCS;
} # KCS


sub PDN {		# 070000
    $jR = $mem[$mr];				# single precision unsigned number
    if ($jR & 040000) {
	$jR |= -040000;				# extend sign for short signed number
    }
    printf "%d\n", $jR;				# print single precision number
} # PDN

sub PDD {		# 072000
    $jR = $mem[$mr++];
    $jR += $mem[$mr] << 15;			# double precision unsigned number
    if ($jR & 04000000000) {
	$jR |= -04000000000;			# extend sign for long signed number
    }
    printf "%ld\n", $jR;			# print double precision number
} # PDD

sub PCH {		# 074000
    printf "%c", $jR = $mem[$mr] & 0177;	# print single character
    print "\n" if ($opt_t or $opttx) and $jR != 012;	# trace '\n' unless LF
} # PCH

sub PRF {		# 076000
    my ($num, $sign, $format, $i);
    my @nums = ();				# print string with optional numeric printf %d formats
    $jR = $mem[$mr];				# 0 if argument is NULL string ""
    $format = convString($mr, 0);		# raw string
    $i = 1;
    @nums = ();
    while ($format =~ m/
	    (					# $1
		%
		([# +-]?)			# $2
		(\d+)?				# $3
		(\.\d+)?			# $4
		(l?)				# $5
		([csdDuUboOxX])			# $6
	    )
	/gx) {
	$tmp = $mem[$pc++];			# fetch address of next number parameter
	while (defined($mr = $tmp & 0777) and $tmp & 01000) {
	    $tmp = $mem[$mr];		# @ indirect memory reference
	    if (($tmp & 01777) == ($mr | 01000)) {
		$num = sprintf "%o", $mr;
		warn "*** EXEC ERROR: infinite indirect loop at LOC $num\n";
		return;
	    }
	}
	if ($6 eq 'c') {
	    $num = $mem[$mr] & 0177;		# %c	single character
	} elsif ($6 eq 's') {
	    $num = convString($mr, 0);		# %s	raw string
	} else {
	    $num = $mem[$mr];			# %d %D %u %U %b %o %O %x %X or %ld etc
	    if ($5 or $6 eq 'D' or $6 eq 'U' or $6 eq 'O') {
		$num += $mem[$mr+1] << 15;	# %D %U %O or "ld" etc
		$sign = -04000000000;		# double precision number
	    } else {
		$sign = -040000;		# %d etc  single precision number
	    }
	    if (($6 eq 'd' or $6 eq 'D') and ($num & $sign)) {
		$num |= $sign;			# sign extend signed negative number
	    }
	}
	push @nums, $num;			# collect parameters for each %d etc format element
	printf("\t%03o   %03o\t\t%2d %s\t'%s'\n", $pc-1, $mr, $i, $1, $6 eq 'c' ? chr $num : $num) if $opttx;
	$i++;
    }
    printf $format, @nums;			# use perl printf for output of collected elements
    print "\n" if ($opt_t or $opttx) and $format !~ m/\n$/;	# trace '\n' unless LF at end of string
} # PRF
