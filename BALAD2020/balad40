#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2000-2020  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#	balad assembler and interpreter
#
########################################################################

use strict;
use integer;
use warnings;
use Term::ReadKey;
use Term::ReadLine;

########################################################################
#
#	Opcodes	- Hash used during assembly
#
########################################################################

my %opCodes = (
	JMP	=> [ 000000, 1, ],	# may not JMP to carry
	JMS	=> [ 002000, 1, ],
	JZR	=> [ 004000, 1, ],	JEQ	=> [ 004000, 1, ],
	JNR	=> [ 006000, 1, ],	JNE	=> [ 006000, 1, ],

	JZC	=> [ 010000, 1, ],	JLE	=> [ 010000, 1, ],
	JNC	=> [ 012000, 1, ],	JGT	=> [ 012000, 1, ],
	JEZ	=> [ 014000, 1, ],	JLT	=> [ 014000, 1, ],
	JBN	=> [ 016000, 1, ],	JGE	=> [ 016000, 1, ],

	CMP	=> [ 020000, 0, ],	# double operand ops can use carry
	AND	=> [ 022000, 0, ],
	ADD	=> [ 024000, 0, ],
	SUB	=> [ 026000, 0, ],

	LDA	=> [ 030000, 0, ],	# may load carry
	STA	=> [ 032000, 0, ],	# may operate on carry
	CLR	=> [ 034000, 0, ],	# may operate on carry
	SWP	=> [ 036000, 1, ],	# inhibit operation on carry

	COM	=> [ 040000, 0, ],
	NEG	=> [ 042000, 1, ],
	INC	=> [ 044000, 1, ],
	DEC	=> [ 046000, 1, ],

	ROL	=> [ 050000, 1, ],
	ROR	=> [ 052000, 1, ],
	TST	=> [ 054000, 0, ],	# may test carry
	ASR	=> [ 056000, 1, ],

	KDN	=> [ 060000, 1, ],
	KDD	=> [ 062000, 1, ],
	KCH	=> [ 064000, 1, ],
	KCS	=> [ 066000, 1, ],

	PDN	=> [ 070000, 0, ],	TDN	=> [ 070000, 0, ],	# may print carry
	PDD	=> [ 072000, 1, ],	TDD	=> [ 072000, 1, ],
	PCH	=> [ 074000, 0, ],	TCH	=> [ 074000, 0, ],	# may print carry
	PRF	=> [ 076000, 1, ],	TCS	=> [ 076000, 1, ],
);

########################################################################
#
#	Opcodes	- Array of OpCode names for disassembly listing
#
########################################################################

my @opNames = (
	"JMP",	# 000000
	"JMS",	# 002000
	"JZR",	# 004000
	"JNR",	# 006000
                        
	"JZC",	# 010000
	"JNC",	# 012000
	"JEZ",	# 014000
	"JBN",	# 016000
                        
	"CMP",	# 020000
	"AND",	# 022000
	"ADD",	# 024000
	"SUB",	# 026000
                        
	"LDA",	# 030000
	"STA",	# 032000
	"CLR",	# 034000
	"SWP",	# 036000
                        
	"COM",	# 040000
	"NEG",	# 042000
	"INC",	# 044000
	"DEC",	# 046000
                        
	"ROL",	# 050000
	"ROR",	# 052000
	"TST",	# 054000
	"ASR",	# 056000
                        
	"KDN",	# 060000
	"KDD",	# 062000
	"KCH",	# 064000
	"KCS",	# 066000
                        
	"PDN",	# 070000
	"PDD",	# 072000
	"PCH",	# 074000
	"PRF",	# 076000
);

########################################################################
#
#	Opcodes	- Array of subroutine references used during execution
#
########################################################################

my @opSubs = (
	\&JMP,	# 000000
	\&JMS,	# 002000
	\&JZR,	# 004000
	\&JNR,	# 006000
                        
	\&JZC,	# 010000
	\&JNC,	# 012000
	\&JEZ,	# 014000
	\&JBN,	# 016000
                        
	\&CMP,	# 020000
	\&AND,	# 022000
	\&ADD,	# 024000
	\&SUB,	# 026000
                        
	\&LDA,	# 030000
	\&STA,	# 032000
	\&CLR,	# 034000
	\&SWP,	# 036000
                        
	\&COM,	# 040000
	\&NEG,	# 042000
	\&INC,	# 044000
	\&DEC,	# 046000
                        
	\&ROL,	# 050000
	\&ROR,	# 052000
	\&TST,	# 054000
	\&ASR,	# 056000
                        
	\&KDN,	# 060000
	\&KDD,	# 062000
	\&KCH,	# 064000
	\&KCS,	# 066000
                        
	\&PDN,	# 070000
	\&PDD,	# 072000
	\&PCH,	# 074000
	\&PRF,	# 076000
);

my $loc		= 0100;		# first default location
my $state	= 0;		# 0 none  1 data  2 code
my $comment	= '';
my $label	= '';
my ($op, $num, $sign, $dval, $val, $str, $i, $byte, $byte0, $errFlag, $backslash);
my ($pc, $mr, $instr, $tmp, $jtA, $jtC);

my @mem		= (0) x 01000;	# the BALAD memory 0 - 777 initialised to 0 (HLT)
my %comments	= ();
my %labels	= ();

my $named = $0;
$named =~ s#.*[/\\]##;		# delete directory names in path
my @argv = ();
my $argv;

format STDERR =
Usage:	@<<<<[ -lh][ balad_source_file ...]
	$named
	-l	list output during entry and execution
	  -d	additionally list C, ACC, L1 and MR in decimal
	  -o	additionally list C, ACC, L1 and MR in octal
	  -x	additionally list C, ACC, L1 and MR in hexadecimal
	  -b	additionally list C, ACC, L1 and MR in binary
	  	in each case show valuses before and after execution
	-m	show execution time in microsecond resolution
	-h	help, ouput this Usage text only
	any file ending in .lst is interpreted as a list of files.
$Id: balad40 1.1 $
.

use vars qw($opt_l $opt_d $opt_o $opt_x $opt_b $opt_m $opt_T $opt_h);
use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    '<>'  => sub { push(@argv, @_); },	# Transfer file argument to @argv
    'l'   => \$opt_l,
    'd'   => \$opt_d,
    'o'   => \$opt_o,
    'x'   => \$opt_x,
    'b'   => \$opt_b,
    'm'   => \$opt_m,
    'T'   => \$opt_T,
    'h'   => \$opt_h,
);

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

my ($t0, $t1, $sec, $usec);
if ($opt_m) {
    use Time::HiRes qw(gettimeofday);
}

$errFlag = 0;
my $term = Term::ReadLine->new('balad');
unshift(@argv, '-') if !@argv;	# use stdin if no further arguments
while ($argv = shift @argv) {
    unless (open (IN, $argv)) {
	warn "can't open input file $argv";
	next;
    }
    if ($argv =~ /\.lst$/) {	# x.lst is a list of filenames
	while (<IN>) {		# read next entry from x.lst into $_
	    chop;		# $_ is a filname entry out of x.lst
	    push(@argv, $_);	# put next filename on end of @argv
	}
    } else {
	processFile();
    }
    close(IN);
}

########################################################################
#
#	Typical BALAD assembler language code
#
#	When 'bas' is first started, all locations 0 to 777 are set to 00000
#	which means they are all HLT instructions.
#	If pre-tested routines are to be entered from files, they should
#	be listed as arguments to the 'bas' command:
#	    bas multply.bal divide.bal double.bal
#	After the last file interactive mode is entered.
#
#	In interactive mode the first column of octal numbers are output
#	by the assembler (input from stdin, not from a file).
#	Lables are followed by a colon (:) and are optional.
#	White space can be 1 or more spaces or tabs.
#	When a program is run with the R command (no address), it starts
#	at 'main'. Alternatively use 100R to start this program.
#	Either way the Acummulator (LOC 0) and Carry (LOC 777) are cleared.
#
#		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#		;
#		;	Comment block
#		;
#		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#
#		LOC	10	; initialised data block
# 010	op1:	99
# 011	op2:	81
# 012	sum:	BLK	1	; uninitialised data block
# 013
#		LOC	100	; code block
# 100	main:	CLR	C	; clear carry before addition
# 101		LDA	op1
# 102		ADD	op2
# 103		STA	sum
# 104		PDN	sum
# 105		HLT
#
########################################################################

sub processFile {
    printf "	" if $argv eq "-";
    $str = $dval = $val = undef;
    $state = $byte0 = 0;
    while (<IN>) {
	if (m/^(\s*([A-Z]+)\s*(@?)\s*([0-7]+))(\s*;.*)?/ and
	    defined($op = $opCodes{$2}[0]) ) {
	    $num = oct $4;
	    if ($num > (($opCodes{$2}[1] || $3) ? 0776 : 0777)) {
		$tmp = sprintf "mr %o is illegal %s at loc %o", $num, $num eq 0777 ? "carry" : "memory reference", $loc;
		warn "*** ERROR: $tmp\n";
		$errFlag = 1;
	    }
	    $val = $op | ($3 ? 01000 : 0) | $num; 		# BALAD code statement
	    $comment = $5;
	    $state = $op ? 2 : 1;				# follow with code or data if JMP
    #no warnings;
    #    printf "%o	%o	%o\n", $op, $3 ? 01000 : 0, oct $4;
    #    print "op = $op	@ = '$3'	mr = $4	val = $val	comment = '$5' state  = $state\n";
    #use warnings;
	} elsif (m/^(\s*HLT)(\s*;.*)?$/) {
	    $val = 0;						# code HLT (JMP 0)
	    $comment = $2;
	    $state = 1;						# end of code block
	} elsif (m/^(\s*ADR\s*(@?)\s*([0-7]+))(\s*;.*)?/) {
	    $val = ($2 ? 01000 : 0) | oct $3;			# indirect address pointer 
	    $comment = $4;						# do not change $state
	} elsif ($state <= 1) {
	    if (m/^(\s*LOC\s*([0-7]+))(\s*;.*)?$/) {
		$num = oct $2;
		goto TestLOC;
	    } elsif (m/^(\s*BLK\s*([0-7]+))(\s*;.*)?$/) {
		$num = $loc + oct $2;
	      TestLOC:
		$comment = $3;
		if ($num <= 01 or $num >= 0776) {
		    $num = sprintf "%o", $num;
		    warn "*** ERROR: LOC $num; 0, 1, 776 and 777 are reserved, > 777 are illegal\n";
		    $errFlag = 1;
		    goto Retry;
		} elsif ($mem[$num]) {
		    $num = sprintf "%o", $num;
		    goto MemERR2;		# LOC already initialised
		} else {
		    $loc = $num;		# LOC 02 to 0775
		    $state = 1;
		}
	    } elsif (m/^(\s*([1-9][0-9]*)([lL]?))(\s*;.*)?$/) {
		$num = $2;					# unsigned decimal number				
		goto TestNUM;
	    } elsif (m/^(\s*(0[0-7]*)([lL]?))(\s*;.*)?$/ or	      # octal number
		     m/^(\s*(0[xX][0-9a-fA-F]+)([lL]?))(\s*;.*)?$/ or # hexadecimal number
		     m/^(\s*(0[bB][01]+)([lL]?))(\s*;.*)?$/) {	      # binary number
		$num = oct $2;
	      TestNUM:
		$comment = $4;
		if ($3) {
		    if ($num <= 07777777777) {
			$val  = $num & 077777;			# long number
			$dval = ($num >> 15) & 077777;
		    } else {
			warn "*** ERROR: unsigned long number must be less than 1,073,741,824 (10000000000 octal)\n";
			$errFlag = 1;
			goto Retry;
		    }
		} else {
		    if ($num <= 077777) {
			$val  = $num;				# short number
		    } else {
			warn "*** ERROR: unsigned short number must be less than 32,768 (100000 octal)\n";
			$errFlag = 1;
			goto Retry;
		    }
		}
	    } elsif (m/^(\s*([-+])([1-9][0-9]*)([lL]?))(\s*;.*)?$/) {
		$num = $3;					# signed decimal
		$comment = $5;
		if ($4) {
		    if ($num <= 03777777777) {			# long number
			$num  =  -$num & 07777777777 if $2 eq '-';
			$val  = $num & 077777;
			$dval = ($num >> 15) & 077777;
		    } else {
			warn "*** ERROR: absolute value of long signed number must be less than 536,870,912 (4000000000 octal)\n";
			$errFlag = 1;
			goto Retry;
		    }
		} else {
		    if ($num <= 037777) {			# short number
			$val  = $2 eq '-' ? -$num & 077777 : $num;
		    } else {
			warn "*** ERROR: absolute value of short signed number must be less than 16,384 (40000 octal)\n";
			$errFlag = 1;
			goto Retry;
		    }
		}
	    } elsif (m/^(\s*"(.*)")(\s*;.*)?$/) {
		$str  = $2;					# character string
		$comment = $3;
	    } elsif (m/^(\s*;.*)?$/) {
		$comment = $3;					# end of entry
		$state   = 0;
	    } elsif ($state == 0) {
		########################################################################
		#   run and debugging commands
		########################################################################
		if (m/^\s*([0-7]{0,3})\s*r$/) {
		    $pc = $1 ? oct $1 : 0100;			# <pc> run (default 0100 main)
		    $mem[0] = $mem[0777] = $jtA = $jtC = 0;	# clear all other CPU registers
		    print "\n";
		    run();
		} elsif (m/^\s*q$/) {
		    exit;					# quit BALAD
		}
	    } else {
		warn "*** ERROR: syntax error - code or data not recognised\n";
		$errFlag = 1;
		goto Retry;
	    }
	} else {
	    $num = sprintf "%o", $loc;
	    warn "*** ERROR: syntax error - code block at loc $num must be terminated by a JMP or HLT instruction\n";
	    $errFlag = 1;
	    goto Retry;
	}
	########################################################################
	#   End of one input line
	########################################################################
	if ($opt_l) {
	    ########################################################################
	    #   Optionally list code or data produced - check for address error
	    ########################################################################
	    if (defined $dval) {
		if ($loc >= 0776 or $mem[$loc]) { goto MemERR0; }
		printf "	%03o	%05o	%s", $loc, $val, $_;
		if ($loc + 1 >= 0776 or $mem[$loc + 1]) { $loc++; goto MemERR0; }
		printf "	%03o	%05o	(%#o)\n", $loc + 1, $dval, ($dval << 15) + $val;
	    } elsif (defined $val) {
		if ($loc >= 0776 or $mem[$loc]) { goto MemERR0; }
		printf "	%03o	%05o	%s", $loc, $val, $_;
	    } elsif (defined $str) {
		$byte0 = $backslash = $i = 0;
		foreach $byte (split //, $str) {
		    $byte = ord($byte);
		    if ($backslash) {
			if ($byte == 0156) {
			    $byte = 012;	# "\n"  LINE FEED
			} elsif ($byte == 0164) {
			    $byte = 011;	# "\t"  TAB
			}
		    } elsif ($byte == 0134) {
			$backslash = 1;		# '\'
			next;
		    }
		    $backslash = 0;		# all other chars following '\' unchanged
		    if ($byte0) {
			if ($loc + $i >= 0776 or $mem[$loc + $i]) { $loc += $i; goto MemERR0; }
			if ($i == 0) {
			    printf "	%03o	%05o	%c %c	\"%s\"\n", $loc + $i++, (($byte & 0177) << 8) + ($byte0 & 0177), $byte0, $byte, $str;
			} else {
			    printf "	%03o	%05o	%c %c\n", $loc + $i++, (($byte & 0177) << 8) + ($byte0 & 0177), $byte0, $byte;
			}
			$byte0 = 0;
		    } else {
			$byte0 = $byte;
		    }
		}
		if ($loc + $i >= 0776 or $mem[$loc + $i]) { $loc += $i; goto MemERR0; }
		printf "	%03o	%05o	%c", $loc + $i, ($byte0 & 0177), $byte0;
		if ($i == 0) {
		    printf "	\"%s\"", $str;
		}
		if ($comment) {
		    printf "	%s\n", $comment;
		} else {
		    print "\n";
		}
	    } else {
		printf "			%s", $_;	# all other lines
	    }
	    if ($comment) {
		$comments{$loc} .= "$comment\n";
		$comment = '';
	    }
	}
	########################################################################
	#   Store code or data in memory - check for address error
	#   This section is missed if optional listing found an error
	########################################################################
	if (defined $val) {			# single word of code or numeric data
	    if ($loc >= 0776 or $mem[$loc]) { goto MemERR1; }
	    $mem[$loc++] = $val;
	    if (defined $dval) {		# high order word of numeric data
		if ($loc >= 0776 or $mem[$loc]) { goto MemERR1; }
		$mem[$loc++] = $dval;
	    }
	} elsif (defined $str) {		# "character string" (may be more than 1 word)
	    $byte0 = $backslash = $i = 0;
	    foreach $byte (split //, $str) {
		$byte = ord($byte);
		if ($backslash) {
		    if ($byte == 0156) {
			$byte = 012;		# "\n"  LINE FEED
		    } elsif ($byte == 0164) {
			$byte = 011;		# "\t"  TAB
		    }
		} elsif ($byte == 0134) {
		    $backslash = 1;		# '\'
		    next;
		}
		$backslash = 0;			# all other chars following '\' unchanged
		if ($byte0) {
		    if ($loc >= 0776 or $mem[$loc]) { goto MemERR1; }
		    $mem[$loc++] = (($byte & 0177) << 8) + ($byte0 & 0177);
		    $byte0 = 0;
		} else {
		    $byte0 = $byte;
		}
	    }
	    if ($loc >= 0776 or $mem[$loc]) { goto MemERR1; }
	    $mem[$loc++] = ($byte0 & 0177);
	}
	goto Retry;
      MemERR0:
	print "\n";
      MemERR1:
	$byte0 = 0;
	$num = sprintf "%o", $loc;
      MemERR2:
	warn "*** ERROR: LOC $num has already been initialised with code or data\n";
	$errFlag = 1;
      Retry:
	$str = $dval = $val = undef;
	if ($argv eq "-") {
	    if ($state == 0) {
		printf "	";
	    } else {
		printf "%03o	", $loc;
	    }
	}
    }
} # processFile

########################################################################
#
#   Run BALAD code
#
########################################################################

sub run {
    if ($errFlag) {
	warn "*** ERROR: cannot run because of previous compile errors\n";
	exit;
    }
    printf ("	%3o run	********\n", $pc) if $opt_l;
    if ($opt_m) {
	$t0 = [gettimeofday];
    }
    while (($instr = $tmp = $mem[$pc++]) != 0) {	# fetch instruction, increment $pc
	$op = ($instr & 076000) >> 10;			# op code
	if ($opt_l) {
	    printf ("	%3o %05o %3s %s%03o", $pc - 1, $instr, $opNames[$op], $instr & 01000 ? "@" : "", $instr & 0777);
	    if ($op < 030 and $op >= 010) {		# ignore I/O and JMP instructions
		if ($opt_d) {
		    printf ("	C %d ACC %5d L1 %5d MR %5d", $mem[0777], $mem[0], $mem[1], $mem[$tmp & 0777]);
		} elsif ($opt_o) {
		    printf ("	C %d ACC %05o L1 %05o MR %05o", $mem[0777], $mem[0], $mem[1], $mem[$tmp & 0777]);
		} elsif ($opt_x) {
		    printf ("	C %d ACC %04x L1 %04x MR %04x", $mem[0777], $mem[0], $mem[1], $mem[$tmp & 0777]);
		} elsif ($opt_b) {
		    printf ("	C %d ACC %015b L1 %015b MR %015b", $mem[0777], $mem[0], $mem[1], $mem[$tmp & 0777]);
		}
	    } else {
		printf "\n";
	    }
	}
	my $n = 0;					# indirect counter
	while (defined($mr = $tmp & 0777) and $tmp & 01000) {
	    $tmp = $mem[$mr];				# @ indirect memory reference
	    if ($n++ > 10) {
		$num = sprintf "%o", $mr;
		warn "*** EXEC ERROR: very long indirect loop at LOC $num\n";
		return;
	    }
	}
	$opSubs[$op]->();				# execute op code (all op's exist) with resolved $mr
	if ($opt_l) {
	    if ($op < 030 and $op >= 010) {		# ignore I/O and JMP instructions
		if ($opt_d) {
		    printf (" ==> C %d ACC %5d L1 %5d MR %5d", $mem[0777], $mem[0], $mem[1], $mem[$tmp & 0777]);
		} elsif ($opt_o) {
		    printf (" ==> C %d ACC %05o L1 %05o MR %05o", $mem[0777], $mem[0], $mem[1], $mem[$tmp & 0777]);
		} elsif ($opt_x) {
		    printf (" ==> C %d ACC %04x L1 %04x MR %04x", $mem[0777], $mem[0], $mem[1], $mem[$tmp & 0777]);
		} elsif ($opt_b) {
		    printf (" ==> C %d ACC %015b L1 %015b MR %015b", $mem[0777], $mem[0], $mem[1], $mem[$tmp & 0777]);
		}
		printf "\n";
	    }
	}
    }
    printf ("	%3o HLT	********\n", $pc - 1) if $opt_l;
    if ($opt_m) {
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	printf "%3d.%03d,%03d seconds\n", $sec, int($usec/1000), $usec%1000;
    }
} # run

########################################################################
#
#   Functions to execute each op-code
#
########################################################################


sub JMP {		# 000000
    $pc = $mr;
} # JMP

sub JMS {		# 002000
    $mem[$mr] = $pc;	# save return address
    $pc = $mr + 1;
} # JMS

sub JZR {		# 004000
    $pc = $mr if $jtA == 0;
} # JZR

sub JNR {		# 006000
    $pc = $mr if $jtA != 0;
} # JNR
                        

sub JZC {		# 010000
    $pc = $mr if $jtC == 0;
} # JZC

sub JNC {		# 012000
    $pc = $mr if $jtC != 0;
} # JNC

sub JEZ {		# 014000
    $pc = $mr if $jtA == 0 or $jtC == 0;
} # JEZ

sub JBN {		# 016000
    $pc = $mr if $jtA != 0 and $jtC != 0;
} # JBN
                        

sub CMP {		# 020000
    $jtA = $mem[0] + ($mem[0777] ^ 1) + ($mem[$mr] ^ 077777);	# add twos complement to accumulator and carry
    if ($jtA & ~077777) {		# overflow ?
	$jtA &= 077777;			# yes - mask accumulator in jump tester only
	$jtC = $mem[0777] ^ 000001;	# complement carry in jump tester only
    }
} # CMP

sub AND {		# 022000
    $jtA = $mem[0] &= $mem[$mr];	# and accumulator (carry not affected)
} # AND

sub ADD {		# 024000
    $jtA = $mem[0] + $mem[0777] + $mem[$mr];	# add to accumulator and carry
    if ($jtA & ~077777) {		# overflow ?
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] ^= 000001;	# complement carry
    }
    $mem[0] = $jtA;
} # ADD

sub SUB {		# 026000
    $jtA = $mem[0] + ($mem[0777] ^ 1) + ($mem[$mr] ^ 077777);	# add twos complement to accumulator and carry
    if ($jtA & ~077777) {		# overflow ?
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] ^= 000001;	# complement carry
    }
    $mem[0] = $jtA;
} # SUB
                        

sub LDA {		# 030000
    $jtA = $mem[0] = $mem[$mr];		# load accumulator
} # LDA

sub STA {		# 032000
    $jtA = $mem[$mr] = $mem[0];		# store accumulator
    $jtC = $mem[0777] &= 1 if $mr == 0777; # may set or reset carry
} # STA

sub CLR {		# 034000
    $jtA = $mem[$mr] = 0;		# clear memory location
    $jtC = 0 if $mr == 0777;		# may also clear carry
} # CLR

sub SWP {		# 036000
    $jtA = (($tmp = $mem[$mr]) & 0177) << 8;
    $mem[$mr] = $jtA += $tmp >> 8;
} # SWP
                        

sub COM {		# 040000
    $jtA = $mem[$mr] = $mem[$mr] ^ 077777;	# bitwise complement memory location
    $jtC = $mem[0777] &= 1 if $mr == 0777;	# may also complement carry
} # COM

sub NEG {		# 042000
    $jtA = ($mem[0777] ^ 1) + ($mem[$mr] ^ 077777); # twos complement memory location
    if ($jtA & ~077777) {		# overflow ?
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] ^= 000001;	# complement carry
    }
    $mem[$mr] = $jtA;
} # NEG

sub INC {		# 044000
    $jtA = $mem[$mr] + 1;
    if ($jtA & ~077777) {
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] ^= 000001;	# complement carry
    }
    $mem[$mr] = $jtA;
} # INC

sub DEC {		# 046000
    $jtA = $mem[$mr] - 1;
    if ($jtA & ~077777) {
	$jtA &= 077777;			# yes - mask accumulator
	$jtC = $mem[0777] ^= 000001;	# complement carry
    }
    $mem[$mr] = $jtA;
} # DEC
                        

sub ROL {		# 050000	# shift operators should not operate on carry
    $jtA = ($mem[$mr] << 1) + $mem[0777];
    $jtC = $mem[0777] = $jtA >> 15;
    $mem[$mr] = $jtA &= 077777;
} # ROL

sub ROR {		# 052000
    $jtC = $mem[$mr] & 000001;
    $jtA = ($mem[$mr] >> 1) + ($mem[0777] << 14);
    $mem[$mr] = $jtA;
    $mem[0777] = $jtC;
} # ROR

sub TST {		# 054000
    $jtA = $mem[$mr];
    $jtC = $mem[0777] & 1 if $mr == 0777; # may test carry
} # TST

sub ASR {		# 056000
    $jtC = $mem[$mr] & 000001;
    $jtA = $mem[$mr];
    $jtA += (($jtA & 040000) << 1);
    $mem[$mr] = $jtA >>= 1;
    $mem[0777] = $jtC;
} # ASR
                        

sub KDN {		# 060000
  RepeatKDN:
    $_ = $term->readline("Enter a short number: ");
    $jtA = +$_;
    $jtA = oct $jtA if $jtA =~ m/^0/;
    if ($jtA > 077777) {
	warn "*** ERROR: unsigned short number must be less than 32,768 (100000 octal)\n";
	goto RepeatKDN;
    }
    $mem[$mr] = $jtA;
} # KDN

sub KDD {		# 062000
  RepeatKDD:
    $_ = $term->readline("Enter a long number: ");
    $jtA = +$_;
    $jtA = oct $jtA if $jtA =~ m/^0/;
    if ($jtA > 07777777777) {
	warn "*** ERROR: unsigned long number must be less than 1,073,741,824 (10000000000 octal)\n";
	goto RepeatKDD;
    }
    $mem[$mr] = $jtA & 077777;		# long number
    $mem[$mr+1] = ($jtA >> 15) & 077777;
} # KDD

sub KCH {		# 064000
    ReadMode('cbreak');
    $byte = ReadKey(0);			# single character from keyboard (stdin)
    print $byte;			# echo
    $jtA = $mem[$mr] = ord $byte;
    ReadMode('normal');
} # KCH

sub KCS {		# 066000
    $_ = $term->readline("Enter a text string: ");
    $byte0 = $backslash = $jtA = 0;
    foreach $byte (split //, $_) {
	$jtA = 1 if $byte ne "0";
	$byte = ord($byte);
	if ($backslash) {
	    if ($byte == 0156) {
		$byte = 012;	# "\n"  LINE FEED
	    } elsif ($byte == 0164) {
		$byte = 011;	# "\t"  TAB
	    }
	} elsif ($byte == 0134) {
	    $backslash = 1;		# '\'
	    next;
	}
	$backslash = 0;		# all other chars following '\' unchanged
	if ($byte0) {
	    if ($mr >= 0776) { goto KCSERR0; }
	    $num = (($byte & 0177) << 8) + ($byte0 & 0177);
	    printf("	%03o	%05o	%c %c\n", $mr, $num, $byte0, $byte) if $opt_l;
	    $mem[$mr++] = $num;
	    $byte0 = 0;
	} else {
	    $byte0 = $byte;
	}
    }
    if ($mr >= 0776) { goto KCSERR0; }
    $num = ($byte0 & 0177);
    printf("	%03o	%05o	%c\n", $mr, $num, $byte0) if $opt_l;
    $mem[$mr] = $num;
    return;
  KCSERR0:
    $num = sprintf "%o", $mr;
    warn "*** ERROR: String will overflow memory at loc $num - exit\n";
    exit;
} # KCS
                        

sub PDN {		# 070000
    printf "%d", $jtA = $mem[$mr];	# print single precision unsigned number
} # PDN

sub PDD {		# 072000
    $jtA = $mem[$mr++];
    $jtA += $mem[$mr] << 15;
    printf "%ld", $jtA;			# print double precision unsigned number
} # PDD

sub PCH {		# 074000
    printf "%c", $jtA = $mem[$mr];	# print single character
} # PCH

sub PRF {		# 076000
    my @nums = ();			# print string with optional numeric printf %d formats
    $jtA = $mem[$mr];			# 0 if argument is NULL string ""
    for (;;) {
	$num = $mem[$mr++];
	last if ($byte = $num & 0177) == 0;
	push @nums, sprintf "%c", $byte;
	last if ($byte = ($num & 077600) >> 8) == 0;
	push @nums, sprintf "%c", $byte;
    }
    my $format = join "", @nums;	# format string parameter
    $i = 1;
    @nums = ();
    while ($format =~ m/(%([# +-]?)(\d+)?(\.\d+)?(l?)([dDuUboOxX]))/g) {
	$tmp = $mem[$pc++];			# fetch address of next number parameter
	while (defined($mr = $tmp & 0777) and $tmp & 01000) {
	    $tmp = $mem[$mr];		# @ indirect memory reference
	    if (($tmp & 01777) == ($mr | 01000)) {
		$num = sprintf "%o", $mr;
		warn "*** EXEC ERROR: infinite indirect loop at LOC $num\n";
		return;
	    }
	}
	if ($5 or $6 eq "D" or $6 eq "U" or $6 eq "O") {	# or "ld" etc
	    $num = $mem[$mr];		# double precision number
	    $num += $mem[$mr+1] << 15;
	    $sign = -04000000000;
	} else {
	    $num = $mem[$mr];		# single precision number
	    $sign = -040000;
	}
	if (($6 eq "d" or $6 eq "D") and $num & $sign) {
	    $num |= $sign;		# sign extend signed negative number
	}
	push @nums, $num;		# collect numeric parameter for each %d etc format element
	printf("%d '%s'	pc = %3o mr = %3o num = %d %#o sign = %#o\n", $i, $1, $pc - 1, $mr, $num, $num, $sign) if $opt_l;
	$i++;
    }
    printf $format, @nums;		# uses perl printf for output of collected numbers
} # PRF
